{"file_contents":{"client/screens/ChatsScreen.tsx":{"content":"import React, { useCallback } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  FlatList,\n  Pressable,\n  Image,\n  ActivityIndicator,\n  RefreshControl,\n} from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useBottomTabBarHeight } from \"@react-navigation/bottom-tabs\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useAuth } from \"@/contexts/AuthContext\";\nimport { usePresence } from \"@/contexts/PresenceContext\";\nimport { Colors, Spacing, BorderRadius, Typography } from \"@/constants/theme\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { getApiUrl } from \"@/lib/query-client\";\nimport type { User, Message } from \"@shared/schema\";\nimport type { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport type { RootStackParamList } from \"@/navigation/RootStackNavigator\";\n\ntype NavigationProp = NativeStackNavigationProp<RootStackParamList>;\n\ninterface Conversation {\n  user: User;\n  lastMessage: Message;\n}\n\nexport default function ChatsScreen() {\n  const insets = useSafeAreaInsets();\n  const tabBarHeight = useBottomTabBarHeight();\n  const { theme } = useTheme();\n  const { token } = useAuth();\n  const { isUserOnline } = usePresence();\n  const navigation = useNavigation<NavigationProp>();\n\n  const { data: conversations = [], isLoading, refetch, isRefetching } = useQuery<Conversation[]>({\n    queryKey: [\"/api/conversations\"],\n    queryFn: async () => {\n      const response = await fetch(new URL(\"/api/conversations\", getApiUrl()).toString(), {\n        headers: { Authorization: `Bearer ${token}` },\n      });\n      if (!response.ok) throw new Error(\"Failed to fetch conversations\");\n      return response.json();\n    },\n    refetchInterval: 5000,\n  });\n\n  const getAvatarSource = useCallback((user: User) => {\n    const photos = user.photos || [];\n    const avatarIndex = user.avatarIndex || 0;\n    const photo = photos[avatarIndex] || photos[0];\n    \n    if (photo) {\n      if (photo.startsWith(\"/avatars/\")) {\n        const avatarMap: Record<string, any> = {\n          \"/avatars/avatar1.png\": require(\"../../assets/avatars/avatar1.png\"),\n          \"/avatars/avatar2.png\": require(\"../../assets/avatars/avatar2.png\"),\n          \"/avatars/avatar3.png\": require(\"../../assets/avatars/avatar3.png\"),\n          \"/avatars/avatar4.png\": require(\"../../assets/avatars/avatar4.png\"),\n          \"/avatars/avatar5.png\": require(\"../../assets/avatars/avatar5.png\"),\n          \"/avatars/avatar6.png\": require(\"../../assets/avatars/avatar6.png\"),\n        };\n        return avatarMap[photo] || require(\"../../assets/avatars/avatar1.png\");\n      }\n      return { uri: new URL(photo.startsWith(\"/objects/\") ? photo : `/objects/${photo}`, getApiUrl()).toString() };\n    }\n    return require(\"../../assets/avatars/avatar1.png\");\n  }, []);\n\n  const formatTime = (date: Date | string) => {\n    const d = new Date(date);\n    const now = new Date();\n    const diff = now.getTime() - d.getTime();\n    const days = Math.floor(diff / (1000 * 60 * 60 * 24));\n    \n    if (days === 0) {\n      return d.toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" });\n    } else if (days === 1) {\n      return \"Yesterday\";\n    } else if (days < 7) {\n      return d.toLocaleDateString([], { weekday: \"short\" });\n    } else {\n      return d.toLocaleDateString([], { month: \"short\", day: \"numeric\" });\n    }\n  };\n\n  const renderConversation = ({ item }: { item: Conversation }) => (\n    <Pressable\n      style={({ pressed }) => [\n        styles.conversationCard,\n        { backgroundColor: theme.cardBackground, opacity: pressed ? 0.95 : 1 },\n      ]}\n      onPress={() => navigation.navigate(\"Chat\", { user: item.user })}\n    >\n      <View style={styles.avatarContainer}>\n        <Image source={getAvatarSource(item.user)} style={styles.avatar} />\n        {(isUserOnline(item.user.id) || item.user.isOnline) && <View style={[styles.onlineIndicator, { backgroundColor: theme.online }]} />}\n      </View>\n\n      <View style={styles.conversationInfo}>\n        <View style={styles.conversationHeader}>\n          <ThemedText style={styles.userName} numberOfLines={1}>\n            {item.user.name}\n          </ThemedText>\n          <ThemedText style={[styles.timestamp, { color: theme.textSecondary }]}>\n            {formatTime(item.lastMessage.createdAt!)}\n          </ThemedText>\n        </View>\n        <ThemedText style={[styles.lastMessage, { color: theme.textSecondary }]} numberOfLines={1}>\n          {item.lastMessage.content}\n        </ThemedText>\n      </View>\n    </Pressable>\n  );\n\n  return (\n    <ThemedView style={styles.container}>\n      <View style={[styles.header, { paddingTop: insets.top + Spacing.lg }]}>\n        <ThemedText style={styles.headerTitle}>Chats</ThemedText>\n      </View>\n\n      {isLoading ? (\n        <View style={styles.loadingContainer}>\n          <ActivityIndicator size=\"large\" color={theme.primary} />\n        </View>\n      ) : (\n        <FlatList\n          data={conversations}\n          renderItem={renderConversation}\n          keyExtractor={(item) => item.user.id}\n          contentContainerStyle={[styles.list, { paddingBottom: tabBarHeight + Spacing.xl }]}\n          showsVerticalScrollIndicator={false}\n          refreshControl={\n            <RefreshControl refreshing={isRefetching} onRefresh={refetch} tintColor={theme.primary} />\n          }\n          ListEmptyComponent={\n            <View style={styles.emptyContainer}>\n              <Feather name=\"message-circle\" size={48} color={theme.textSecondary} />\n              <ThemedText style={[styles.emptyTitle, { color: theme.textSecondary }]}>\n                No conversations yet\n              </ThemedText>\n              <ThemedText style={[styles.emptySubtitle, { color: theme.textSecondary }]}>\n                Start a conversation in Community\n              </ThemedText>\n            </View>\n          }\n        />\n      )}\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  header: {\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.lg,\n  },\n  headerTitle: {\n    ...Typography.h3,\n  },\n  loadingContainer: {\n    flex: 1,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  list: {\n    paddingHorizontal: Spacing.xl,\n    gap: Spacing.sm,\n  },\n  conversationCard: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    borderRadius: BorderRadius.sm,\n    padding: Spacing.lg,\n  },\n  avatarContainer: {\n    position: \"relative\",\n  },\n  avatar: {\n    width: 50,\n    height: 50,\n    borderRadius: 25,\n  },\n  onlineIndicator: {\n    position: \"absolute\",\n    bottom: 2,\n    right: 2,\n    width: 12,\n    height: 12,\n    borderRadius: 6,\n    borderWidth: 2,\n    borderColor: \"#FFFFFF\",\n  },\n  conversationInfo: {\n    flex: 1,\n    marginLeft: Spacing.lg,\n  },\n  conversationHeader: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    marginBottom: Spacing.xs,\n  },\n  userName: {\n    ...Typography.body,\n    fontWeight: \"600\",\n    flex: 1,\n  },\n  timestamp: {\n    ...Typography.caption,\n    marginLeft: Spacing.sm,\n  },\n  lastMessage: {\n    ...Typography.small,\n  },\n  emptyContainer: {\n    alignItems: \"center\",\n    paddingTop: Spacing[\"5xl\"] * 2,\n  },\n  emptyTitle: {\n    ...Typography.body,\n    fontWeight: \"600\",\n    marginTop: Spacing.lg,\n  },\n  emptySubtitle: {\n    ...Typography.small,\n    marginTop: Spacing.xs,\n  },\n});\n","path":null,"size_bytes":7599,"size_tokens":null},"client/components/ThemedView.tsx":{"content":"import { View, type ViewProps } from \"react-native\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\n\nexport type ThemedViewProps = ViewProps & {\n  lightColor?: string;\n  darkColor?: string;\n};\n\nexport function ThemedView({\n  style,\n  lightColor,\n  darkColor,\n  ...otherProps\n}: ThemedViewProps) {\n  const { theme, isDark } = useTheme();\n\n  const backgroundColor =\n    isDark && darkColor\n      ? darkColor\n      : !isDark && lightColor\n        ? lightColor\n        : theme.backgroundRoot;\n\n  return <View style={[{ backgroundColor }, style]} {...otherProps} />;\n}\n","path":null,"size_bytes":563,"size_tokens":null},"server/websocket.ts":{"content":"import { WebSocketServer, WebSocket } from \"ws\";\nimport type { Server, IncomingMessage } from \"http\";\nimport { verifyToken } from \"./auth\";\nimport { storage } from \"./storage\";\n\ninterface AuthenticatedWebSocket extends WebSocket {\n  userId?: string;\n  isAlive?: boolean;\n}\n\ninterface PresenceMessage {\n  type: \"presence\" | \"user_status\";\n  userId?: string;\n  isOnline?: boolean;\n  onlineUsers?: string[];\n}\n\nconst OFFLINE_GRACE_PERIOD_MS = 15000;\n\nclass PresenceManager {\n  private wss: WebSocketServer;\n  private userConnections: Map<string, Set<AuthenticatedWebSocket>> = new Map();\n  private offlineTimeouts: Map<string, NodeJS.Timeout> = new Map();\n  private heartbeatInterval: NodeJS.Timeout | null = null;\n\n  constructor(server: Server) {\n    this.wss = new WebSocketServer({ server, path: \"/ws\" });\n    this.setupConnectionHandler();\n    this.startHeartbeat();\n  }\n\n  private setupConnectionHandler() {\n    this.wss.on(\"connection\", async (ws: AuthenticatedWebSocket, req: IncomingMessage) => {\n      const url = new URL(req.url || \"\", `http://${req.headers.host}`);\n      const token = url.searchParams.get(\"token\");\n\n      if (!token) {\n        ws.close(4001, \"No token provided\");\n        return;\n      }\n\n      const decoded = verifyToken(token);\n      if (!decoded) {\n        ws.close(4002, \"Invalid token\");\n        return;\n      }\n\n      const user = await storage.getUser(decoded.userId);\n      if (!user) {\n        ws.close(4003, \"User not found\");\n        return;\n      }\n\n      ws.userId = decoded.userId;\n      ws.isAlive = true;\n\n      const existingTimeout = this.offlineTimeouts.get(decoded.userId);\n      if (existingTimeout) {\n        clearTimeout(existingTimeout);\n        this.offlineTimeouts.delete(decoded.userId);\n      }\n\n      const wasOffline = !this.userConnections.has(decoded.userId) || \n                         this.userConnections.get(decoded.userId)!.size === 0;\n\n      this.addConnection(decoded.userId, ws);\n      \n      if (wasOffline) {\n        await this.setUserOnline(decoded.userId, true);\n      } else {\n        this.broadcastUserStatus(decoded.userId, true);\n      }\n\n      this.sendOnlineUsers(ws);\n\n      ws.on(\"pong\", () => {\n        ws.isAlive = true;\n      });\n\n      ws.on(\"close\", () => {\n        this.removeConnection(decoded.userId, ws);\n        \n        if (!this.userConnections.has(decoded.userId) || \n            this.userConnections.get(decoded.userId)!.size === 0) {\n          this.scheduleOffline(decoded.userId);\n        }\n      });\n\n      ws.on(\"error\", (error: Error) => {\n        console.error(\"WebSocket error:\", error);\n      });\n    });\n  }\n\n  private addConnection(userId: string, ws: AuthenticatedWebSocket) {\n    if (!this.userConnections.has(userId)) {\n      this.userConnections.set(userId, new Set());\n    }\n    this.userConnections.get(userId)!.add(ws);\n  }\n\n  private removeConnection(userId: string, ws: AuthenticatedWebSocket) {\n    const connections = this.userConnections.get(userId);\n    if (connections) {\n      connections.delete(ws);\n      if (connections.size === 0) {\n        this.userConnections.delete(userId);\n      }\n    }\n  }\n\n  private scheduleOffline(userId: string) {\n    const existingTimeout = this.offlineTimeouts.get(userId);\n    if (existingTimeout) {\n      clearTimeout(existingTimeout);\n    }\n\n    const timeout = setTimeout(async () => {\n      if (!this.userConnections.has(userId) || \n          this.userConnections.get(userId)!.size === 0) {\n        await this.setUserOnline(userId, false);\n      }\n      this.offlineTimeouts.delete(userId);\n    }, OFFLINE_GRACE_PERIOD_MS);\n\n    this.offlineTimeouts.set(userId, timeout);\n  }\n\n  private async setUserOnline(userId: string, isOnline: boolean) {\n    const currentlyOnline = this.isUserOnline(userId);\n    \n    if (!isOnline && currentlyOnline) {\n      return;\n    }\n    \n    try {\n      await storage.updateUser(userId, { \n        isOnline, \n        lastSeen: new Date() \n      });\n    } catch (error) {\n      console.error(\"Failed to update user online status:\", error);\n    }\n    \n    this.broadcastUserStatus(userId, isOnline);\n  }\n\n  private broadcastUserStatus(userId: string, isOnline: boolean) {\n    const message: PresenceMessage = {\n      type: \"user_status\",\n      userId,\n      isOnline,\n    };\n\n    this.wss.clients.forEach((client: WebSocket) => {\n      if (client.readyState === WebSocket.OPEN) {\n        client.send(JSON.stringify(message));\n      }\n    });\n  }\n\n  private sendOnlineUsers(ws: AuthenticatedWebSocket) {\n    const onlineUsers = Array.from(this.userConnections.keys());\n    const message: PresenceMessage = {\n      type: \"presence\",\n      onlineUsers,\n    };\n    \n    if (ws.readyState === WebSocket.OPEN) {\n      ws.send(JSON.stringify(message));\n    }\n  }\n\n  private startHeartbeat() {\n    this.heartbeatInterval = setInterval(() => {\n      this.wss.clients.forEach((client) => {\n        const ws = client as AuthenticatedWebSocket;\n        if (ws.isAlive === false) {\n          if (ws.userId) {\n            this.removeConnection(ws.userId, ws);\n            this.scheduleOffline(ws.userId);\n          }\n          return ws.terminate();\n        }\n        \n        ws.isAlive = false;\n        ws.ping();\n      });\n    }, 30000);\n  }\n\n  public getOnlineUsers(): string[] {\n    return Array.from(this.userConnections.keys());\n  }\n\n  public isUserOnline(userId: string): boolean {\n    return this.userConnections.has(userId) && \n           this.userConnections.get(userId)!.size > 0;\n  }\n\n  public close() {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n    }\n    this.offlineTimeouts.forEach(timeout => clearTimeout(timeout));\n    this.offlineTimeouts.clear();\n    this.wss.close();\n  }\n}\n\nlet presenceManager: PresenceManager | null = null;\n\nexport function initializeWebSocket(server: Server): PresenceManager {\n  presenceManager = new PresenceManager(server);\n  console.log(\"WebSocket server initialized on /ws\");\n  return presenceManager;\n}\n\nexport function getPresenceManager(): PresenceManager | null {\n  return presenceManager;\n}\n","path":null,"size_bytes":6053,"size_tokens":null},"client/contexts/AuthContext.tsx":{"content":"import React, { createContext, useContext, useState, useEffect, useCallback, type ReactNode } from 'react';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport { apiRequest, getApiUrl } from '@/lib/query-client';\nimport type { User } from '@shared/schema';\n\ninterface AuthContextType {\n  user: User | null;\n  token: string | null;\n  isLoading: boolean;\n  isAuthenticated: boolean;\n  login: (email: string, password: string) => Promise<void>;\n  register: (email: string, password: string, name: string) => Promise<void>;\n  logout: () => Promise<void>;\n  updateUser: (data: Partial<User>) => Promise<void>;\n  refreshUser: () => Promise<void>;\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\nconst TOKEN_KEY = '@lanchat_token';\nconst USER_KEY = '@lanchat_user';\n\nexport function AuthProvider({ children }: { children: ReactNode }) {\n  const [user, setUser] = useState<User | null>(null);\n  const [token, setToken] = useState<string | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    loadStoredAuth();\n  }, []);\n\n  const loadStoredAuth = async () => {\n    try {\n      const [storedToken, storedUser] = await Promise.all([\n        AsyncStorage.getItem(TOKEN_KEY),\n        AsyncStorage.getItem(USER_KEY),\n      ]);\n\n      if (storedToken && storedUser) {\n        setToken(storedToken);\n        setUser(JSON.parse(storedUser));\n        \n        try {\n          const response = await fetch(new URL('/api/auth/me', getApiUrl()).toString(), {\n            headers: { Authorization: `Bearer ${storedToken}` },\n          });\n          \n          if (response.ok) {\n            const userData = await response.json();\n            setUser(userData);\n            await AsyncStorage.setItem(USER_KEY, JSON.stringify(userData));\n          } else {\n            await clearAuth();\n          }\n        } catch {\n          // Keep stored data if network fails\n        }\n      }\n    } catch (error) {\n      console.error('Failed to load auth:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const clearAuth = async () => {\n    await AsyncStorage.multiRemove([TOKEN_KEY, USER_KEY]);\n    setToken(null);\n    setUser(null);\n  };\n\n  const login = async (email: string, password: string) => {\n    const response = await apiRequest('POST', '/api/auth/login', { email, password });\n\n    const data = await response.json();\n    \n    await AsyncStorage.setItem(TOKEN_KEY, data.token);\n    await AsyncStorage.setItem(USER_KEY, JSON.stringify(data.user));\n    \n    setToken(data.token);\n    setUser(data.user);\n  };\n\n  const register = async (email: string, password: string, name: string) => {\n    const response = await apiRequest('POST', '/api/auth/register', { email, password, name });\n\n    const data = await response.json();\n    \n    await AsyncStorage.setItem(TOKEN_KEY, data.token);\n    await AsyncStorage.setItem(USER_KEY, JSON.stringify(data.user));\n    \n    setToken(data.token);\n    setUser(data.user);\n  };\n\n  const logout = async () => {\n    try {\n      if (token) {\n        await fetch(new URL('/api/auth/logout', getApiUrl()).toString(), {\n          method: 'POST',\n          headers: { Authorization: `Bearer ${token}` },\n        });\n      }\n    } catch {\n      // Ignore logout API errors\n    }\n    await clearAuth();\n  };\n\n  const updateUser = async (data: Partial<User>) => {\n    if (!token) throw new Error('Not authenticated');\n\n    const response = await fetch(new URL('/api/users/profile', getApiUrl()).toString(), {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${token}`,\n      },\n      body: JSON.stringify(data),\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'Failed to update profile');\n    }\n\n    const updatedUser = await response.json();\n    setUser(updatedUser);\n    await AsyncStorage.setItem(USER_KEY, JSON.stringify(updatedUser));\n  };\n\n  const refreshUser = useCallback(async () => {\n    if (!token) return;\n\n    try {\n      const response = await fetch(new URL('/api/auth/me', getApiUrl()).toString(), {\n        headers: { Authorization: `Bearer ${token}` },\n      });\n\n      if (response.ok) {\n        const userData = await response.json();\n        setUser(userData);\n        await AsyncStorage.setItem(USER_KEY, JSON.stringify(userData));\n      }\n    } catch (error) {\n      console.error('Failed to refresh user:', error);\n    }\n  }, [token]);\n\n  return (\n    <AuthContext.Provider\n      value={{\n        user,\n        token,\n        isLoading,\n        isAuthenticated: !!user && !!token,\n        login,\n        register,\n        logout,\n        updateUser,\n        refreshUser,\n      }}\n    >\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\nexport function useAuth() {\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n}\n","path":null,"size_bytes":5001,"size_tokens":null},"client/components/Spacer.tsx":{"content":"import { View } from \"react-native\";\n\ntype Props = {\n  width?: number;\n  height?: number;\n};\n\nexport default function Spacer(props: Props) {\n  const width: number = props.width ?? 1;\n  const height: number = props.height ?? 1;\n\n  return (\n    <View\n      style={{\n        width,\n        height,\n      }}\n    />\n  );\n}\n","path":null,"size_bytes":318,"size_tokens":null},"client/components/VerificationBadge.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet } from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius, Typography } from \"@/constants/theme\";\n\ntype VerificationLevel = \"none\" | \"email\" | \"photo\" | \"id\";\n\ninterface VerificationBadgeProps {\n  isVerified: boolean;\n  verificationLevel?: VerificationLevel;\n  size?: \"small\" | \"medium\" | \"large\";\n  showLabel?: boolean;\n}\n\nconst getBadgeConfig = (level: VerificationLevel) => {\n  switch (level) {\n    case \"id\":\n      return { icon: \"shield\" as const, label: \"ID Verified\", color: \"#10B981\" };\n    case \"photo\":\n      return { icon: \"check-circle\" as const, label: \"Photo Verified\", color: \"#3B82F6\" };\n    case \"email\":\n      return { icon: \"mail\" as const, label: \"Email Verified\", color: \"#8B5CF6\" };\n    default:\n      return null;\n  }\n};\n\nexport function VerificationBadge({\n  isVerified,\n  verificationLevel = \"none\",\n  size = \"small\",\n  showLabel = false,\n}: VerificationBadgeProps) {\n  const { theme } = useTheme();\n\n  if (!isVerified || verificationLevel === \"none\") {\n    return null;\n  }\n\n  const config = getBadgeConfig(verificationLevel);\n  if (!config) return null;\n\n  const iconSize = size === \"small\" ? 12 : size === \"medium\" ? 16 : 20;\n  const badgeSize = size === \"small\" ? 18 : size === \"medium\" ? 24 : 32;\n\n  if (showLabel) {\n    return (\n      <View\n        style={[\n          styles.labelBadge,\n          { backgroundColor: `${config.color}15` },\n        ]}\n      >\n        <Feather name={config.icon} size={iconSize} color={config.color} />\n        <ThemedText style={[styles.labelText, { color: config.color }]}>\n          {config.label}\n        </ThemedText>\n      </View>\n    );\n  }\n\n  return (\n    <View\n      style={[\n        styles.iconBadge,\n        {\n          width: badgeSize,\n          height: badgeSize,\n          borderRadius: badgeSize / 2,\n          backgroundColor: config.color,\n        },\n      ]}\n    >\n      <Feather name={config.icon} size={iconSize} color=\"#FFFFFF\" />\n    </View>\n  );\n}\n\nexport function SafetyIndicator() {\n  const { theme } = useTheme();\n\n  return (\n    <View style={[styles.safetyContainer, { backgroundColor: theme.cardBackground }]}>\n      <View style={styles.safetyHeader}>\n        <Feather name=\"shield\" size={18} color={theme.primary} />\n        <ThemedText style={[styles.safetyTitle, { color: theme.text }]}>\n          Safety Tips\n        </ThemedText>\n      </View>\n      <View style={styles.safetyTips}>\n        <View style={styles.tipRow}>\n          <Feather name=\"check\" size={14} color=\"#10B981\" />\n          <ThemedText style={[styles.tipText, { color: theme.textSecondary }]}>\n            Never share personal financial information\n          </ThemedText>\n        </View>\n        <View style={styles.tipRow}>\n          <Feather name=\"check\" size={14} color=\"#10B981\" />\n          <ThemedText style={[styles.tipText, { color: theme.textSecondary }]}>\n            Report suspicious behavior immediately\n          </ThemedText>\n        </View>\n        <View style={styles.tipRow}>\n          <Feather name=\"check\" size={14} color=\"#10B981\" />\n          <ThemedText style={[styles.tipText, { color: theme.textSecondary }]}>\n            Meet in public places for first meetings\n          </ThemedText>\n        </View>\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  iconBadge: {\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  labelBadge: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.xs,\n    borderRadius: BorderRadius.full,\n    gap: Spacing.xs,\n  },\n  labelText: {\n    ...Typography.small,\n    fontWeight: \"600\",\n  },\n  safetyContainer: {\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.sm,\n    marginTop: Spacing.lg,\n  },\n  safetyHeader: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n    marginBottom: Spacing.md,\n  },\n  safetyTitle: {\n    ...Typography.body,\n    fontWeight: \"600\",\n  },\n  safetyTips: {\n    gap: Spacing.sm,\n  },\n  tipRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n  },\n  tipText: {\n    ...Typography.small,\n    flex: 1,\n  },\n});\n","path":null,"size_bytes":4298,"size_tokens":null},"client/hooks/useTheme.ts":{"content":"import { Colors } from \"@/constants/theme\";\nimport { useColorScheme } from \"@/hooks/useColorScheme\";\n\nexport function useTheme() {\n  const colorScheme = useColorScheme();\n  const isDark = colorScheme === \"dark\";\n  const theme = Colors[colorScheme ?? \"light\"];\n\n  return {\n    theme,\n    isDark,\n  };\n}\n","path":null,"size_bytes":302,"size_tokens":null},"client/screens/OnboardingScreen.tsx":{"content":"import React, { useState } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  Pressable,\n  ScrollView,\n  ActivityIndicator,\n  Alert,\n} from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useAuth } from \"@/contexts/AuthContext\";\nimport { Colors, Spacing, BorderRadius, Typography } from \"@/constants/theme\";\nimport { LANGUAGES } from \"@/constants/languages\";\nimport { Feather } from \"@expo/vector-icons\";\n\nexport default function OnboardingScreen() {\n  const insets = useSafeAreaInsets();\n  const { theme } = useTheme();\n  const { updateUser } = useAuth();\n\n  const [step, setStep] = useState(1);\n  const [nativeLanguage, setNativeLanguage] = useState(\"\");\n  const [learningLanguages, setLearningLanguages] = useState<string[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n\n  const toggleLearningLanguage = (language: string) => {\n    setLearningLanguages(prev =>\n      prev.includes(language)\n        ? prev.filter(l => l !== language)\n        : [...prev, language]\n    );\n  };\n\n  const handleNext = async () => {\n    if (step === 1) {\n      if (!nativeLanguage) {\n        Alert.alert(\"Error\", \"Please select your native language\");\n        return;\n      }\n      setStep(2);\n    } else {\n      if (learningLanguages.length === 0) {\n        Alert.alert(\"Error\", \"Please select at least one language to learn\");\n        return;\n      }\n\n      setIsLoading(true);\n      try {\n        await updateUser({ nativeLanguage, learningLanguages });\n      } catch (error: any) {\n        Alert.alert(\"Error\", error.message || \"Failed to save preferences\");\n      } finally {\n        setIsLoading(false);\n      }\n    }\n  };\n\n  return (\n    <ThemedView style={styles.container}>\n      <View style={[styles.header, { paddingTop: insets.top + Spacing.xl }]}>\n        <View style={styles.progressContainer}>\n          <View style={[styles.progressDot, { backgroundColor: theme.primary }]} />\n          <View style={[styles.progressLine, { backgroundColor: step === 2 ? theme.primary : theme.border }]} />\n          <View style={[styles.progressDot, { backgroundColor: step === 2 ? theme.primary : theme.border }]} />\n        </View>\n        <ThemedText style={styles.stepText}>Step {step} of 2</ThemedText>\n      </View>\n\n      <ScrollView\n        style={styles.content}\n        contentContainerStyle={[styles.scrollContent, { paddingBottom: insets.bottom + 100 }]}\n        showsVerticalScrollIndicator={false}\n      >\n        {step === 1 ? (\n          <>\n            <ThemedText style={styles.title}>What is your native language?</ThemedText>\n            <ThemedText style={[styles.subtitle, { color: theme.textSecondary }]}>\n              Select the language you speak fluently\n            </ThemedText>\n\n            <View style={styles.languageGrid}>\n              {LANGUAGES.map((lang) => (\n                <Pressable\n                  key={lang.code}\n                  style={({ pressed }) => [\n                    styles.languageChip,\n                    {\n                      backgroundColor: nativeLanguage === lang.name ? theme.primary : theme.backgroundSecondary,\n                      opacity: pressed ? 0.8 : 1,\n                    },\n                  ]}\n                  onPress={() => setNativeLanguage(lang.name)}\n                >\n                  <ThemedText\n                    style={[\n                      styles.languageChipText,\n                      { color: nativeLanguage === lang.name ? \"#FFFFFF\" : theme.text },\n                    ]}\n                  >\n                    {lang.name}\n                  </ThemedText>\n                  {nativeLanguage === lang.name && (\n                    <Feather name=\"check\" size={16} color=\"#FFFFFF\" style={styles.checkIcon} />\n                  )}\n                </Pressable>\n              ))}\n            </View>\n          </>\n        ) : (\n          <>\n            <ThemedText style={styles.title}>What languages do you want to learn?</ThemedText>\n            <ThemedText style={[styles.subtitle, { color: theme.textSecondary }]}>\n              Select one or more languages\n            </ThemedText>\n\n            <View style={styles.languageGrid}>\n              {LANGUAGES.filter(l => l.name !== nativeLanguage).map((lang) => (\n                <Pressable\n                  key={lang.code}\n                  style={({ pressed }) => [\n                    styles.languageChip,\n                    {\n                      backgroundColor: learningLanguages.includes(lang.name) ? theme.primary : theme.backgroundSecondary,\n                      opacity: pressed ? 0.8 : 1,\n                    },\n                  ]}\n                  onPress={() => toggleLearningLanguage(lang.name)}\n                >\n                  <ThemedText\n                    style={[\n                      styles.languageChipText,\n                      { color: learningLanguages.includes(lang.name) ? \"#FFFFFF\" : theme.text },\n                    ]}\n                  >\n                    {lang.name}\n                  </ThemedText>\n                  {learningLanguages.includes(lang.name) && (\n                    <Feather name=\"check\" size={16} color=\"#FFFFFF\" style={styles.checkIcon} />\n                  )}\n                </Pressable>\n              ))}\n            </View>\n          </>\n        )}\n      </ScrollView>\n\n      <View style={[styles.footer, { paddingBottom: insets.bottom + Spacing.lg, backgroundColor: theme.backgroundRoot }]}>\n        {step === 2 && (\n          <Pressable\n            style={({ pressed }) => [\n              styles.backButton,\n              { borderColor: theme.border, opacity: pressed ? 0.8 : 1 },\n            ]}\n            onPress={() => setStep(1)}\n          >\n            <ThemedText style={{ color: theme.text }}>Back</ThemedText>\n          </Pressable>\n        )}\n        <Pressable\n          style={({ pressed }) => [\n            styles.nextButton,\n            { backgroundColor: theme.primary, opacity: pressed ? 0.9 : 1, flex: step === 2 ? 1 : undefined },\n          ]}\n          onPress={handleNext}\n          disabled={isLoading}\n        >\n          {isLoading ? (\n            <ActivityIndicator color=\"#FFFFFF\" />\n          ) : (\n            <ThemedText style={styles.nextButtonText}>\n              {step === 1 ? \"Continue\" : \"Get Started\"}\n            </ThemedText>\n          )}\n        </Pressable>\n      </View>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  header: {\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.xl,\n  },\n  progressContainer: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    marginBottom: Spacing.md,\n  },\n  progressDot: {\n    width: 12,\n    height: 12,\n    borderRadius: 6,\n  },\n  progressLine: {\n    width: 60,\n    height: 2,\n    marginHorizontal: Spacing.xs,\n  },\n  stepText: {\n    ...Typography.small,\n    color: \"#757575\",\n  },\n  content: {\n    flex: 1,\n  },\n  scrollContent: {\n    paddingHorizontal: Spacing.xl,\n  },\n  title: {\n    ...Typography.h3,\n    marginBottom: Spacing.sm,\n  },\n  subtitle: {\n    ...Typography.body,\n    marginBottom: Spacing.xl,\n  },\n  languageGrid: {\n    flexDirection: \"row\",\n    flexWrap: \"wrap\",\n    gap: Spacing.sm,\n  },\n  languageChip: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n    borderRadius: BorderRadius.full,\n  },\n  languageChipText: {\n    ...Typography.body,\n  },\n  checkIcon: {\n    marginLeft: Spacing.xs,\n  },\n  footer: {\n    flexDirection: \"row\",\n    paddingHorizontal: Spacing.xl,\n    paddingTop: Spacing.lg,\n    gap: Spacing.md,\n  },\n  backButton: {\n    height: Spacing.buttonHeight,\n    paddingHorizontal: Spacing[\"2xl\"],\n    borderRadius: BorderRadius.sm,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    borderWidth: 1,\n  },\n  nextButton: {\n    height: Spacing.buttonHeight,\n    paddingHorizontal: Spacing[\"3xl\"],\n    borderRadius: BorderRadius.sm,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  nextButtonText: {\n    color: \"#FFFFFF\",\n    ...Typography.body,\n    fontWeight: \"600\",\n  },\n});\n","path":null,"size_bytes":8266,"size_tokens":null},"server/objectAcl.ts":{"content":"import { File } from \"@google-cloud/storage\";\n\nconst ACL_POLICY_METADATA_KEY = \"custom:aclPolicy\";\n\nexport enum ObjectAccessGroupType {}\n\nexport interface ObjectAccessGroup {\n  type: ObjectAccessGroupType;\n  id: string;\n}\n\nexport enum ObjectPermission {\n  READ = \"read\",\n  WRITE = \"write\",\n}\n\nexport interface ObjectAclRule {\n  group: ObjectAccessGroup;\n  permission: ObjectPermission;\n}\n\nexport interface ObjectAclPolicy {\n  owner: string;\n  visibility: \"public\" | \"private\";\n  aclRules?: Array<ObjectAclRule>;\n}\n\nfunction isPermissionAllowed(\n  requested: ObjectPermission,\n  granted: ObjectPermission,\n): boolean {\n  if (requested === ObjectPermission.READ) {\n    return [ObjectPermission.READ, ObjectPermission.WRITE].includes(granted);\n  }\n  return granted === ObjectPermission.WRITE;\n}\n\nabstract class BaseObjectAccessGroup implements ObjectAccessGroup {\n  constructor(\n    public readonly type: ObjectAccessGroupType,\n    public readonly id: string,\n  ) {}\n\n  public abstract hasMember(userId: string): Promise<boolean>;\n}\n\nfunction createObjectAccessGroup(\n  group: ObjectAccessGroup,\n): BaseObjectAccessGroup {\n  throw new Error(`Unknown access group type: ${group.type}`);\n}\n\nexport async function setObjectAclPolicy(\n  objectFile: File,\n  aclPolicy: ObjectAclPolicy,\n): Promise<void> {\n  const [exists] = await objectFile.exists();\n  if (!exists) {\n    throw new Error(`Object not found: ${objectFile.name}`);\n  }\n\n  await objectFile.setMetadata({\n    metadata: {\n      [ACL_POLICY_METADATA_KEY]: JSON.stringify(aclPolicy),\n    },\n  });\n}\n\nexport async function getObjectAclPolicy(\n  objectFile: File,\n): Promise<ObjectAclPolicy | null> {\n  const [metadata] = await objectFile.getMetadata();\n  const aclPolicy = metadata?.metadata?.[ACL_POLICY_METADATA_KEY];\n  if (!aclPolicy) {\n    return null;\n  }\n  return JSON.parse(aclPolicy as string);\n}\n\nexport async function canAccessObject({\n  userId,\n  objectFile,\n  requestedPermission,\n}: {\n  userId?: string;\n  objectFile: File;\n  requestedPermission: ObjectPermission;\n}): Promise<boolean> {\n  const aclPolicy = await getObjectAclPolicy(objectFile);\n  if (!aclPolicy) {\n    return false;\n  }\n\n  if (\n    aclPolicy.visibility === \"public\" &&\n    requestedPermission === ObjectPermission.READ\n  ) {\n    return true;\n  }\n\n  if (!userId) {\n    return false;\n  }\n\n  if (aclPolicy.owner === userId) {\n    return true;\n  }\n\n  for (const rule of aclPolicy.aclRules || []) {\n    const accessGroup = createObjectAccessGroup(rule.group);\n    if (\n      (await accessGroup.hasMember(userId)) &&\n      isPermissionAllowed(requestedPermission, rule.permission)\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","path":null,"size_bytes":2662,"size_tokens":null},"client/components/ErrorFallback.tsx":{"content":"import React, { useState } from \"react\";\nimport { reloadAppAsync } from \"expo\";\nimport {\n  StyleSheet,\n  View,\n  Pressable,\n  ScrollView,\n  Text,\n  Modal,\n} from \"react-native\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius, Fonts } from \"@/constants/theme\";\n\nexport type ErrorFallbackProps = {\n  error: Error;\n  resetError: () => void;\n};\n\nexport function ErrorFallback({ error, resetError }: ErrorFallbackProps) {\n  const { theme } = useTheme();\n  const [isModalVisible, setIsModalVisible] = useState(false);\n\n  const handleRestart = async () => {\n    try {\n      await reloadAppAsync();\n    } catch (restartError) {\n      console.error(\"Failed to restart app:\", restartError);\n      resetError();\n    }\n  };\n\n  const formatErrorDetails = (): string => {\n    let details = `Error: ${error.message}\\n\\n`;\n    if (error.stack) {\n      details += `Stack Trace:\\n${error.stack}`;\n    }\n    return details;\n  };\n\n  return (\n    <ThemedView style={styles.container}>\n      {__DEV__ ? (\n        <Pressable\n          onPress={() => setIsModalVisible(true)}\n          style={({ pressed }) => [\n            styles.topButton,\n            {\n              backgroundColor: theme.backgroundDefault,\n              opacity: pressed ? 0.8 : 1,\n            },\n          ]}\n        >\n          <Feather name=\"alert-circle\" size={20} color={theme.text} />\n        </Pressable>\n      ) : null}\n\n      <View style={styles.content}>\n        <ThemedText type=\"h1\" style={styles.title}>\n          Something went wrong\n        </ThemedText>\n\n        <ThemedText type=\"body\" style={styles.message}>\n          Please reload the app to continue.\n        </ThemedText>\n\n        <Pressable\n          onPress={handleRestart}\n          style={({ pressed }) => [\n            styles.button,\n            {\n              backgroundColor: theme.link,\n              opacity: pressed ? 0.9 : 1,\n              transform: [{ scale: pressed ? 0.98 : 1 }],\n            },\n          ]}\n        >\n          <ThemedText\n            type=\"body\"\n            style={[styles.buttonText, { color: theme.buttonText }]}\n          >\n            Try Again\n          </ThemedText>\n        </Pressable>\n      </View>\n\n      {__DEV__ ? (\n        <Modal\n          visible={isModalVisible}\n          animationType=\"slide\"\n          transparent={true}\n          onRequestClose={() => setIsModalVisible(false)}\n        >\n          <View style={styles.modalOverlay}>\n            <ThemedView style={styles.modalContainer}>\n              <View style={styles.modalHeader}>\n                <ThemedText type=\"h2\" style={styles.modalTitle}>\n                  Error Details\n                </ThemedText>\n                <Pressable\n                  onPress={() => setIsModalVisible(false)}\n                  style={({ pressed }) => [\n                    styles.closeButton,\n                    { opacity: pressed ? 0.6 : 1 },\n                  ]}\n                >\n                  <Feather name=\"x\" size={24} color={theme.text} />\n                </Pressable>\n              </View>\n\n              <ScrollView\n                style={styles.modalScrollView}\n                contentContainerStyle={styles.modalScrollContent}\n                showsVerticalScrollIndicator\n              >\n                <View\n                  style={[\n                    styles.errorContainer,\n                    { backgroundColor: theme.backgroundDefault },\n                  ]}\n                >\n                  <Text\n                    style={[\n                      styles.errorText,\n                      {\n                        color: theme.text,\n                        fontFamily: Fonts?.mono || \"monospace\",\n                      },\n                    ]}\n                    selectable\n                  >\n                    {formatErrorDetails()}\n                  </Text>\n                </View>\n              </ScrollView>\n            </ThemedView>\n          </View>\n        </Modal>\n      ) : null}\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    width: \"100%\",\n    height: \"100%\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    padding: Spacing[\"2xl\"],\n  },\n  content: {\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    gap: Spacing.lg,\n    width: \"100%\",\n    maxWidth: 600,\n  },\n  title: {\n    textAlign: \"center\",\n    lineHeight: 40,\n  },\n  message: {\n    textAlign: \"center\",\n    opacity: 0.7,\n    lineHeight: 24,\n  },\n  topButton: {\n    position: \"absolute\",\n    top: Spacing[\"2xl\"] + Spacing.lg,\n    right: Spacing.lg,\n    width: 44,\n    height: 44,\n    borderRadius: BorderRadius.md,\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    zIndex: 10,\n  },\n  button: {\n    paddingVertical: Spacing.lg,\n    borderRadius: BorderRadius.md,\n    paddingHorizontal: Spacing[\"2xl\"],\n    minWidth: 200,\n    shadowColor: \"#000\",\n    shadowOffset: {\n      width: 0,\n      height: 2,\n    },\n    shadowOpacity: 0.1,\n    shadowRadius: 4,\n    elevation: 3,\n  },\n  buttonText: {\n    fontWeight: \"600\",\n    textAlign: \"center\",\n    fontSize: 16,\n  },\n  modalOverlay: {\n    flex: 1,\n    backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n    justifyContent: \"flex-end\",\n  },\n  modalContainer: {\n    width: \"100%\",\n    height: \"90%\",\n    borderTopLeftRadius: BorderRadius.lg,\n    borderTopRightRadius: BorderRadius.lg,\n  },\n  modalHeader: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.lg,\n    paddingTop: Spacing.lg,\n    paddingBottom: Spacing.md,\n    borderBottomWidth: 1,\n    borderBottomColor: \"rgba(128, 128, 128, 0.2)\",\n  },\n  modalTitle: {\n    fontWeight: \"600\",\n  },\n  closeButton: {\n    padding: Spacing.xs,\n  },\n  modalScrollView: {\n    flex: 1,\n  },\n  modalScrollContent: {\n    padding: Spacing.lg,\n  },\n  errorContainer: {\n    width: \"100%\",\n    borderRadius: BorderRadius.md,\n    overflow: \"hidden\",\n    padding: Spacing.lg,\n  },\n  errorText: {\n    fontSize: 12,\n    lineHeight: 18,\n    width: \"100%\",\n  },\n});\n","path":null,"size_bytes":6194,"size_tokens":null},"client/hooks/useColorScheme.web.ts":{"content":"import { useEffect, useState } from \"react\";\nimport { useColorScheme as useRNColorScheme } from \"react-native\";\n\n/**\n * To support static rendering, this value needs to be re-calculated on the client side for web\n */\nexport function useColorScheme() {\n  const [hasHydrated, setHasHydrated] = useState(false);\n\n  useEffect(() => {\n    setHasHydrated(true);\n  }, []);\n\n  const colorScheme = useRNColorScheme();\n\n  if (hasHydrated) {\n    return colorScheme;\n  }\n\n  return \"light\";\n}\n","path":null,"size_bytes":480,"size_tokens":null},"client/components/KeyboardAwareScrollViewCompat.tsx":{"content":"import { Platform, ScrollView, ScrollViewProps } from \"react-native\";\nimport {\n  KeyboardAwareScrollView,\n  KeyboardAwareScrollViewProps,\n} from \"react-native-keyboard-controller\";\n\ntype Props = KeyboardAwareScrollViewProps & ScrollViewProps;\n\n/**\n * KeyboardAwareScrollView that falls back to ScrollView on web.\n * Use this for any screen containing text inputs.\n */\nexport function KeyboardAwareScrollViewCompat({\n  children,\n  keyboardShouldPersistTaps = \"handled\",\n  ...props\n}: Props) {\n  if (Platform.OS === \"web\") {\n    return (\n      <ScrollView\n        keyboardShouldPersistTaps={keyboardShouldPersistTaps}\n        {...props}\n      >\n        {children}\n      </ScrollView>\n    );\n  }\n\n  return (\n    <KeyboardAwareScrollView\n      keyboardShouldPersistTaps={keyboardShouldPersistTaps}\n      {...props}\n    >\n      {children}\n    </KeyboardAwareScrollView>\n  );\n}\n","path":null,"size_bytes":872,"size_tokens":null},"client/lib/query-client.ts":{"content":"import { QueryClient, QueryFunction } from \"@tanstack/react-query\";\n\n/**\n * Gets the base URL for the Express API server (e.g., \"http://localhost:3000\")\n * @returns {string} The API base URL\n */\nexport function getApiUrl(): string {\n  let host = process.env.EXPO_PUBLIC_DOMAIN;\n\n  if (!host) {\n    throw new Error(\"EXPO_PUBLIC_DOMAIN is not set\");\n  }\n\n  let url = new URL(`https://${host}`);\n\n  return url.href;\n}\n\nasync function throwIfResNotOk(res: Response) {\n  if (!res.ok) {\n    const text = (await res.text()) || res.statusText;\n    throw new Error(`${res.status}: ${text}`);\n  }\n}\n\nexport async function apiRequest(\n  method: string,\n  route: string,\n  data?: unknown | undefined,\n): Promise<Response> {\n  const baseUrl = getApiUrl();\n  const url = new URL(route, baseUrl);\n\n  const res = await fetch(url, {\n    method,\n    headers: data ? { \"Content-Type\": \"application/json\" } : {},\n    body: data ? JSON.stringify(data) : undefined,\n    credentials: \"include\",\n  });\n\n  await throwIfResNotOk(res);\n  return res;\n}\n\ntype UnauthorizedBehavior = \"returnNull\" | \"throw\";\nexport const getQueryFn: <T>(options: {\n  on401: UnauthorizedBehavior;\n}) => QueryFunction<T> =\n  ({ on401: unauthorizedBehavior }) =>\n  async ({ queryKey }) => {\n    const baseUrl = getApiUrl();\n    const url = new URL(queryKey.join(\"/\") as string, baseUrl);\n\n    const res = await fetch(url, {\n      credentials: \"include\",\n    });\n\n    if (unauthorizedBehavior === \"returnNull\" && res.status === 401) {\n      return null;\n    }\n\n    await throwIfResNotOk(res);\n    return await res.json();\n  };\n\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      queryFn: getQueryFn({ on401: \"throw\" }),\n      refetchInterval: false,\n      refetchOnWindowFocus: false,\n      staleTime: Infinity,\n      retry: false,\n    },\n    mutations: {\n      retry: false,\n    },\n  },\n});\n","path":null,"size_bytes":1876,"size_tokens":null},"client/navigation/MainTabNavigator.tsx":{"content":"import React from \"react\";\nimport { createBottomTabNavigator } from \"@react-navigation/bottom-tabs\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { BlurView } from \"expo-blur\";\nimport { Platform, StyleSheet } from \"react-native\";\nimport CommunityScreen from \"@/screens/CommunityScreen\";\nimport ChatsScreen from \"@/screens/ChatsScreen\";\nimport ProfileScreen from \"@/screens/ProfileScreen\";\nimport { useTheme } from \"@/hooks/useTheme\";\n\nexport type MainTabParamList = {\n  CommunityTab: undefined;\n  ChatsTab: undefined;\n  ProfileTab: undefined;\n};\n\nconst Tab = createBottomTabNavigator<MainTabParamList>();\n\nexport default function MainTabNavigator() {\n  const { theme, isDark } = useTheme();\n\n  return (\n    <Tab.Navigator\n      initialRouteName=\"CommunityTab\"\n      screenOptions={{\n        tabBarActiveTintColor: theme.primary,\n        tabBarInactiveTintColor: theme.tabIconDefault,\n        tabBarStyle: {\n          position: \"absolute\",\n          backgroundColor: Platform.select({\n            ios: \"transparent\",\n            android: theme.backgroundRoot,\n          }),\n          borderTopWidth: 0,\n          elevation: 0,\n        },\n        tabBarBackground: () =>\n          Platform.OS === \"ios\" ? (\n            <BlurView\n              intensity={100}\n              tint={isDark ? \"dark\" : \"light\"}\n              style={StyleSheet.absoluteFill}\n            />\n          ) : null,\n        headerShown: false,\n      }}\n    >\n      <Tab.Screen\n        name=\"CommunityTab\"\n        component={CommunityScreen}\n        options={{\n          title: \"Community\",\n          tabBarIcon: ({ color, size }) => (\n            <Feather name=\"users\" size={size} color={color} />\n          ),\n        }}\n      />\n      <Tab.Screen\n        name=\"ChatsTab\"\n        component={ChatsScreen}\n        options={{\n          title: \"Chats\",\n          tabBarIcon: ({ color, size }) => (\n            <Feather name=\"message-circle\" size={size} color={color} />\n          ),\n        }}\n      />\n      <Tab.Screen\n        name=\"ProfileTab\"\n        component={ProfileScreen}\n        options={{\n          title: \"Profile\",\n          tabBarIcon: ({ color, size }) => (\n            <Feather name=\"user\" size={size} color={color} />\n          ),\n        }}\n      />\n    </Tab.Navigator>\n  );\n}\n","path":null,"size_bytes":2270,"size_tokens":null},"server/objectStorage.ts":{"content":"import { Storage, File } from \"@google-cloud/storage\";\nimport { Response } from \"express\";\nimport { randomUUID } from \"crypto\";\nimport {\n  ObjectAclPolicy,\n  ObjectPermission,\n  canAccessObject,\n  getObjectAclPolicy,\n  setObjectAclPolicy,\n} from \"./objectAcl\";\n\nconst REPLIT_SIDECAR_ENDPOINT = \"http://127.0.0.1:1106\";\n\nexport const objectStorageClient = new Storage({\n  credentials: {\n    audience: \"replit\",\n    subject_token_type: \"access_token\",\n    token_url: `${REPLIT_SIDECAR_ENDPOINT}/token`,\n    type: \"external_account\",\n    credential_source: {\n      url: `${REPLIT_SIDECAR_ENDPOINT}/credential`,\n      format: {\n        type: \"json\",\n        subject_token_field_name: \"access_token\",\n      },\n    },\n    universe_domain: \"googleapis.com\",\n  },\n  projectId: \"\",\n});\n\nexport class ObjectNotFoundError extends Error {\n  constructor() {\n    super(\"Object not found\");\n    this.name = \"ObjectNotFoundError\";\n    Object.setPrototypeOf(this, ObjectNotFoundError.prototype);\n  }\n}\n\nexport class ObjectStorageService {\n  constructor() {}\n\n  getPublicObjectSearchPaths(): Array<string> {\n    const pathsStr = process.env.PUBLIC_OBJECT_SEARCH_PATHS || \"\";\n    const paths = Array.from(\n      new Set(\n        pathsStr\n          .split(\",\")\n          .map((path) => path.trim())\n          .filter((path) => path.length > 0)\n      )\n    );\n    if (paths.length === 0) {\n      throw new Error(\n        \"PUBLIC_OBJECT_SEARCH_PATHS not set. Create a bucket in 'Object Storage' \" +\n          \"tool and set PUBLIC_OBJECT_SEARCH_PATHS env var (comma-separated paths).\"\n      );\n    }\n    return paths;\n  }\n\n  getPrivateObjectDir(): string {\n    const dir = process.env.PRIVATE_OBJECT_DIR || \"\";\n    if (!dir) {\n      throw new Error(\n        \"PRIVATE_OBJECT_DIR not set. Create a bucket in 'Object Storage' \" +\n          \"tool and set PRIVATE_OBJECT_DIR env var.\"\n      );\n    }\n    return dir;\n  }\n\n  async searchPublicObject(filePath: string): Promise<File | null> {\n    for (const searchPath of this.getPublicObjectSearchPaths()) {\n      const fullPath = `${searchPath}/${filePath}`;\n\n      const { bucketName, objectName } = parseObjectPath(fullPath);\n      const bucket = objectStorageClient.bucket(bucketName);\n      const file = bucket.file(objectName);\n\n      const [exists] = await file.exists();\n      if (exists) {\n        return file;\n      }\n    }\n\n    return null;\n  }\n\n  async downloadObject(file: File, res: Response, cacheTtlSec: number = 3600) {\n    try {\n      const [metadata] = await file.getMetadata();\n      const aclPolicy = await getObjectAclPolicy(file);\n      const isPublic = aclPolicy?.visibility === \"public\";\n      res.set({\n        \"Content-Type\": metadata.contentType || \"application/octet-stream\",\n        \"Content-Length\": metadata.size,\n        \"Cache-Control\": `${\n          isPublic ? \"public\" : \"private\"\n        }, max-age=${cacheTtlSec}`,\n      });\n\n      const stream = file.createReadStream();\n\n      stream.on(\"error\", (err) => {\n        console.error(\"Stream error:\", err);\n        if (!res.headersSent) {\n          res.status(500).json({ error: \"Error streaming file\" });\n        }\n      });\n\n      stream.pipe(res);\n    } catch (error) {\n      console.error(\"Error downloading file:\", error);\n      if (!res.headersSent) {\n        res.status(500).json({ error: \"Error downloading file\" });\n      }\n    }\n  }\n\n  async getObjectEntityUploadURL(): Promise<string> {\n    const privateObjectDir = this.getPrivateObjectDir();\n    if (!privateObjectDir) {\n      throw new Error(\n        \"PRIVATE_OBJECT_DIR not set. Create a bucket in 'Object Storage' \" +\n          \"tool and set PRIVATE_OBJECT_DIR env var.\"\n      );\n    }\n\n    const objectId = randomUUID();\n    const fullPath = `${privateObjectDir}/uploads/${objectId}`;\n\n    const { bucketName, objectName } = parseObjectPath(fullPath);\n\n    return signObjectURL({\n      bucketName,\n      objectName,\n      method: \"PUT\",\n      ttlSec: 900,\n    });\n  }\n\n  async getObjectEntityFile(objectPath: string): Promise<File> {\n    if (!objectPath.startsWith(\"/objects/\")) {\n      throw new ObjectNotFoundError();\n    }\n\n    const parts = objectPath.slice(1).split(\"/\");\n    if (parts.length < 2) {\n      throw new ObjectNotFoundError();\n    }\n\n    const entityId = parts.slice(1).join(\"/\");\n    let entityDir = this.getPrivateObjectDir();\n    if (!entityDir.endsWith(\"/\")) {\n      entityDir = `${entityDir}/`;\n    }\n    const objectEntityPath = `${entityDir}${entityId}`;\n    const { bucketName, objectName } = parseObjectPath(objectEntityPath);\n    const bucket = objectStorageClient.bucket(bucketName);\n    const objectFile = bucket.file(objectName);\n    const [exists] = await objectFile.exists();\n    if (!exists) {\n      throw new ObjectNotFoundError();\n    }\n    return objectFile;\n  }\n\n  normalizeObjectEntityPath(\n    rawPath: string,\n  ): string {\n    if (!rawPath.startsWith(\"https://storage.googleapis.com/\")) {\n      return rawPath;\n    }\n  \n    const url = new URL(rawPath);\n    const rawObjectPath = url.pathname;\n  \n    let objectEntityDir = this.getPrivateObjectDir();\n    if (!objectEntityDir.endsWith(\"/\")) {\n      objectEntityDir = `${objectEntityDir}/`;\n    }\n  \n    if (!rawObjectPath.startsWith(objectEntityDir)) {\n      return rawObjectPath;\n    }\n  \n    const entityId = rawObjectPath.slice(objectEntityDir.length);\n    return `/objects/${entityId}`;\n  }\n\n  async trySetObjectEntityAclPolicy(\n    rawPath: string,\n    aclPolicy: ObjectAclPolicy\n  ): Promise<string> {\n    const normalizedPath = this.normalizeObjectEntityPath(rawPath);\n    if (!normalizedPath.startsWith(\"/\")) {\n      return normalizedPath;\n    }\n\n    const objectFile = await this.getObjectEntityFile(normalizedPath);\n    await setObjectAclPolicy(objectFile, aclPolicy);\n    return normalizedPath;\n  }\n\n  async canAccessObjectEntity({\n    userId,\n    objectFile,\n    requestedPermission,\n  }: {\n    userId?: string;\n    objectFile: File;\n    requestedPermission?: ObjectPermission;\n  }): Promise<boolean> {\n    return canAccessObject({\n      userId,\n      objectFile,\n      requestedPermission: requestedPermission ?? ObjectPermission.READ,\n    });\n  }\n}\n\nfunction parseObjectPath(path: string): {\n  bucketName: string;\n  objectName: string;\n} {\n  if (!path.startsWith(\"/\")) {\n    path = `/${path}`;\n  }\n  const pathParts = path.split(\"/\");\n  if (pathParts.length < 3) {\n    throw new Error(\"Invalid path: must contain at least a bucket name\");\n  }\n\n  const bucketName = pathParts[1];\n  const objectName = pathParts.slice(2).join(\"/\");\n\n  return {\n    bucketName,\n    objectName,\n  };\n}\n\nasync function signObjectURL({\n  bucketName,\n  objectName,\n  method,\n  ttlSec,\n}: {\n  bucketName: string;\n  objectName: string;\n  method: \"GET\" | \"PUT\" | \"DELETE\" | \"HEAD\";\n  ttlSec: number;\n}): Promise<string> {\n  const request = {\n    bucket_name: bucketName,\n    object_name: objectName,\n    method,\n    expires_at: new Date(Date.now() + ttlSec * 1000).toISOString(),\n  };\n  const response = await fetch(\n    `${REPLIT_SIDECAR_ENDPOINT}/object-storage/signed-object-url`,\n    {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(request),\n    }\n  );\n  if (!response.ok) {\n    throw new Error(\n      `Failed to sign object URL, errorcode: ${response.status}, ` +\n        `make sure you're running on Replit`\n    );\n  }\n\n  const { signed_url: signedURL } = await response.json();\n  return signedURL;\n}\n","path":null,"size_bytes":7430,"size_tokens":null},"server/index.ts":{"content":"import express from \"express\";\nimport type { Request, Response, NextFunction } from \"express\";\nimport { registerRoutes } from \"./routes\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\n\nconst app = express();\nconst log = console.log;\n\ndeclare module \"http\" {\n  interface IncomingMessage {\n    rawBody: unknown;\n  }\n}\n\nfunction setupCors(app: express.Application) {\n  app.use((req, res, next) => {\n    const origins = new Set<string>();\n\n    if (process.env.REPLIT_DEV_DOMAIN) {\n      origins.add(`https://${process.env.REPLIT_DEV_DOMAIN}`);\n    }\n\n    if (process.env.REPLIT_DOMAINS) {\n      process.env.REPLIT_DOMAINS.split(\",\").forEach((d) => {\n        origins.add(`https://${d.trim()}`);\n      });\n    }\n\n    const origin = req.header(\"origin\");\n\n    if (origin && origins.has(origin)) {\n      res.header(\"Access-Control-Allow-Origin\", origin);\n      res.header(\n        \"Access-Control-Allow-Methods\",\n        \"GET, POST, PUT, DELETE, OPTIONS\",\n      );\n      res.header(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\");\n      res.header(\"Access-Control-Allow-Credentials\", \"true\");\n    }\n    \n    // Allow requests without origin (Expo Go mobile app)\n    if (!origin) {\n      res.header(\"Access-Control-Allow-Origin\", \"*\");\n      res.header(\n        \"Access-Control-Allow-Methods\",\n        \"GET, POST, PUT, DELETE, OPTIONS\",\n      );\n      res.header(\"Access-Control-Allow-Headers\", \"Content-Type, Authorization\");\n    }\n\n    if (req.method === \"OPTIONS\") {\n      return res.sendStatus(200);\n    }\n\n    next();\n  });\n}\n\nfunction setupBodyParsing(app: express.Application) {\n  app.use(\n    express.json({\n      verify: (req, _res, buf) => {\n        req.rawBody = buf;\n      },\n    }),\n  );\n\n  app.use(express.urlencoded({ extended: false }));\n}\n\nfunction setupRequestLogging(app: express.Application) {\n  app.use((req, res, next) => {\n    const start = Date.now();\n    const path = req.path;\n    let capturedJsonResponse: Record<string, unknown> | undefined = undefined;\n\n    const originalResJson = res.json;\n    res.json = function (bodyJson, ...args) {\n      capturedJsonResponse = bodyJson;\n      return originalResJson.apply(res, [bodyJson, ...args]);\n    };\n\n    res.on(\"finish\", () => {\n      if (!path.startsWith(\"/api\")) return;\n\n      const duration = Date.now() - start;\n\n      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;\n      if (capturedJsonResponse) {\n        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;\n      }\n\n      if (logLine.length > 80) {\n        logLine = logLine.slice(0, 79) + \"\";\n      }\n\n      log(logLine);\n    });\n\n    next();\n  });\n}\n\nfunction getAppName(): string {\n  try {\n    const appJsonPath = path.resolve(process.cwd(), \"app.json\");\n    const appJsonContent = fs.readFileSync(appJsonPath, \"utf-8\");\n    const appJson = JSON.parse(appJsonContent);\n    return appJson.expo?.name || \"App Landing Page\";\n  } catch {\n    return \"App Landing Page\";\n  }\n}\n\nfunction serveExpoManifest(platform: string, res: Response) {\n  const manifestPath = path.resolve(\n    process.cwd(),\n    \"static-build\",\n    platform,\n    \"manifest.json\",\n  );\n\n  if (!fs.existsSync(manifestPath)) {\n    return res\n      .status(404)\n      .json({ error: `Manifest not found for platform: ${platform}` });\n  }\n\n  res.setHeader(\"expo-protocol-version\", \"1\");\n  res.setHeader(\"expo-sfv-version\", \"0\");\n  res.setHeader(\"content-type\", \"application/json\");\n\n  const manifest = fs.readFileSync(manifestPath, \"utf-8\");\n  res.send(manifest);\n}\n\nfunction serveLandingPage({\n  req,\n  res,\n  landingPageTemplate,\n  appName,\n}: {\n  req: Request;\n  res: Response;\n  landingPageTemplate: string;\n  appName: string;\n}) {\n  const forwardedProto = req.header(\"x-forwarded-proto\");\n  const protocol = forwardedProto || req.protocol || \"https\";\n  const forwardedHost = req.header(\"x-forwarded-host\");\n  const host = forwardedHost || req.get(\"host\");\n  const baseUrl = `${protocol}://${host}`;\n  const expsUrl = `${host}`;\n\n  log(`baseUrl`, baseUrl);\n  log(`expsUrl`, expsUrl);\n\n  const html = landingPageTemplate\n    .replace(/BASE_URL_PLACEHOLDER/g, baseUrl)\n    .replace(/EXPS_URL_PLACEHOLDER/g, expsUrl)\n    .replace(/APP_NAME_PLACEHOLDER/g, appName);\n\n  res.setHeader(\"Content-Type\", \"text/html; charset=utf-8\");\n  res.status(200).send(html);\n}\n\nfunction configureExpoAndLanding(app: express.Application) {\n  const templatePath = path.resolve(\n    process.cwd(),\n    \"server\",\n    \"templates\",\n    \"landing-page.html\",\n  );\n  const landingPageTemplate = fs.readFileSync(templatePath, \"utf-8\");\n  const appName = getAppName();\n\n  log(\"Serving static Expo files with dynamic manifest routing\");\n\n  app.use((req: Request, res: Response, next: NextFunction) => {\n    if (req.path.startsWith(\"/api\")) {\n      return next();\n    }\n\n    if (req.path !== \"/\" && req.path !== \"/manifest\") {\n      return next();\n    }\n\n    const platform = req.header(\"expo-platform\");\n    if (platform && (platform === \"ios\" || platform === \"android\")) {\n      return serveExpoManifest(platform, res);\n    }\n\n    if (req.path === \"/\") {\n      return serveLandingPage({\n        req,\n        res,\n        landingPageTemplate,\n        appName,\n      });\n    }\n\n    next();\n  });\n\n  app.use(\"/assets\", express.static(path.resolve(process.cwd(), \"assets\")));\n  app.use(express.static(path.resolve(process.cwd(), \"static-build\")));\n\n  log(\"Expo routing: Checking expo-platform header on / and /manifest\");\n}\n\nfunction setupErrorHandler(app: express.Application) {\n  app.use((err: unknown, _req: Request, res: Response, _next: NextFunction) => {\n    const error = err as {\n      status?: number;\n      statusCode?: number;\n      message?: string;\n    };\n\n    const status = error.status || error.statusCode || 500;\n    const message = error.message || \"Internal Server Error\";\n\n    res.status(status).json({ message });\n\n    throw err;\n  });\n}\n\n(async () => {\n  setupCors(app);\n  setupBodyParsing(app);\n  setupRequestLogging(app);\n\n  configureExpoAndLanding(app);\n\n  const server = await registerRoutes(app);\n\n  setupErrorHandler(app);\n\n  const port = parseInt(process.env.PORT || \"5000\", 10);\n  server.listen(\n    {\n      port,\n      host: \"0.0.0.0\",\n      reusePort: true,\n    },\n    () => {\n      log(`express server serving on port ${port}`);\n    },\n  );\n})();\n","path":null,"size_bytes":6297,"size_tokens":null},"client/components/ThemedText.tsx":{"content":"import { Text, type TextProps } from \"react-native\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Typography } from \"@/constants/theme\";\n\nexport type ThemedTextProps = TextProps & {\n  lightColor?: string;\n  darkColor?: string;\n  type?: \"h1\" | \"h2\" | \"h3\" | \"h4\" | \"body\" | \"small\" | \"link\";\n};\n\nexport function ThemedText({\n  style,\n  lightColor,\n  darkColor,\n  type = \"body\",\n  ...rest\n}: ThemedTextProps) {\n  const { theme, isDark } = useTheme();\n\n  const getColor = () => {\n    if (isDark && darkColor) {\n      return darkColor;\n    }\n\n    if (!isDark && lightColor) {\n      return lightColor;\n    }\n\n    if (type === \"link\") {\n      return theme.link;\n    }\n\n    return theme.text;\n  };\n\n  const getTypeStyle = () => {\n    switch (type) {\n      case \"h1\":\n        return Typography.h1;\n      case \"h2\":\n        return Typography.h2;\n      case \"h3\":\n        return Typography.h3;\n      case \"h4\":\n        return Typography.h4;\n      case \"body\":\n        return Typography.body;\n      case \"small\":\n        return Typography.small;\n      case \"link\":\n        return Typography.link;\n      default:\n        return Typography.body;\n    }\n  };\n\n  return (\n    <Text style={[{ color: getColor() }, getTypeStyle(), style]} {...rest} />\n  );\n}\n","path":null,"size_bytes":1251,"size_tokens":null},"client/components/Button.tsx":{"content":"import React, { ReactNode } from \"react\";\nimport { StyleSheet, Pressable, ViewStyle, StyleProp } from \"react-native\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  WithSpringConfig,\n} from \"react-native-reanimated\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { BorderRadius, Spacing } from \"@/constants/theme\";\n\ninterface ButtonProps {\n  onPress?: () => void;\n  children: ReactNode;\n  style?: StyleProp<ViewStyle>;\n  disabled?: boolean;\n}\n\nconst springConfig: WithSpringConfig = {\n  damping: 15,\n  mass: 0.3,\n  stiffness: 150,\n  overshootClamping: true,\n  energyThreshold: 0.001,\n};\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport function Button({\n  onPress,\n  children,\n  style,\n  disabled = false,\n}: ButtonProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    if (!disabled) {\n      scale.value = withSpring(0.98, springConfig);\n    }\n  };\n\n  const handlePressOut = () => {\n    if (!disabled) {\n      scale.value = withSpring(1, springConfig);\n    }\n  };\n\n  return (\n    <AnimatedPressable\n      onPress={disabled ? undefined : onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n      disabled={disabled}\n      style={[\n        styles.button,\n        {\n          backgroundColor: theme.link,\n          opacity: disabled ? 0.5 : 1,\n        },\n        style,\n        animatedStyle,\n      ]}\n    >\n      <ThemedText\n        type=\"body\"\n        style={[styles.buttonText, { color: theme.buttonText }]}\n      >\n        {children}\n      </ThemedText>\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  button: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.full,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  buttonText: {\n    fontWeight: \"600\",\n  },\n});\n","path":null,"size_bytes":2014,"size_tokens":null},"client/navigation/RootStackNavigator.tsx":{"content":"import React from \"react\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport { useScreenOptions } from \"@/hooks/useScreenOptions\";\nimport { useAuth } from \"@/contexts/AuthContext\";\nimport MainTabNavigator from \"@/navigation/MainTabNavigator\";\nimport AuthScreen from \"@/screens/AuthScreen\";\nimport OnboardingScreen from \"@/screens/OnboardingScreen\";\nimport UserProfileScreen from \"@/screens/UserProfileScreen\";\nimport ChatScreen from \"@/screens/ChatScreen\";\nimport EditProfileScreen from \"@/screens/EditProfileScreen\";\nimport type { User } from \"@shared/schema\";\n\nexport type RootStackParamList = {\n  Auth: undefined;\n  Onboarding: undefined;\n  Main: undefined;\n  UserProfile: { userId: string };\n  Chat: { user: User };\n  EditProfile: undefined;\n};\n\nconst Stack = createNativeStackNavigator<RootStackParamList>();\n\nexport default function RootStackNavigator() {\n  const screenOptions = useScreenOptions();\n  const { isAuthenticated, isLoading, user } = useAuth();\n\n  if (isLoading) {\n    return null;\n  }\n\n  const needsOnboarding = isAuthenticated && user && !user.nativeLanguage;\n\n  return (\n    <Stack.Navigator screenOptions={screenOptions}>\n      {!isAuthenticated ? (\n        <Stack.Screen\n          name=\"Auth\"\n          component={AuthScreen}\n          options={{ headerShown: false }}\n        />\n      ) : needsOnboarding ? (\n        <Stack.Screen\n          name=\"Onboarding\"\n          component={OnboardingScreen}\n          options={{ headerShown: false }}\n        />\n      ) : (\n        <>\n          <Stack.Screen\n            name=\"Main\"\n            component={MainTabNavigator}\n            options={{ headerShown: false }}\n          />\n          <Stack.Screen\n            name=\"UserProfile\"\n            component={UserProfileScreen}\n            options={{ \n              headerTitle: \"Profile\",\n              presentation: \"card\",\n            }}\n          />\n          <Stack.Screen\n            name=\"Chat\"\n            component={ChatScreen}\n            options={{ headerTitle: \"Chat\" }}\n          />\n          <Stack.Screen\n            name=\"EditProfile\"\n            component={EditProfileScreen}\n            options={{ \n              headerTitle: \"Edit Profile\",\n              presentation: \"modal\",\n            }}\n          />\n        </>\n      )}\n    </Stack.Navigator>\n  );\n}\n","path":null,"size_bytes":2326,"size_tokens":null},"client/screens/EditProfileScreen.tsx":{"content":"import React, { useState, useCallback } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  ScrollView,\n  TextInput,\n  Pressable,\n  Image,\n  Alert,\n  ActivityIndicator,\n  Modal,\n  Platform,\n} from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport { useHeaderHeight } from \"@react-navigation/elements\";\nimport { HeaderButton } from \"@react-navigation/elements\";\nimport * as ImagePicker from \"expo-image-picker\";\nimport { File } from \"expo-file-system\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { KeyboardAwareScrollViewCompat } from \"@/components/KeyboardAwareScrollViewCompat\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useAuth } from \"@/contexts/AuthContext\";\nimport { Spacing, BorderRadius, Typography } from \"@/constants/theme\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { LANGUAGES } from \"@/constants/languages\";\nimport { getApiUrl } from \"@/lib/query-client\";\nimport type { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport type { RootStackParamList } from \"@/navigation/RootStackNavigator\";\n\ntype NavigationProp = NativeStackNavigationProp<RootStackParamList>;\n\nconst MAX_PHOTOS = 4;\n\nconst COUNTRIES = [\n  \"United States\", \"United Kingdom\", \"Canada\", \"Australia\", \"Spain\",\n  \"France\", \"Germany\", \"Italy\", \"Brazil\", \"Mexico\", \"Japan\", \"China\",\n  \"South Korea\", \"India\", \"Russia\", \"Netherlands\", \"Sweden\", \"Poland\",\n  \"Turkey\", \"Vietnam\", \"Thailand\", \"Indonesia\", \"Philippines\", \"Argentina\",\n  \"Colombia\", \"Peru\", \"Chile\", \"Portugal\", \"Belgium\", \"Switzerland\",\n  \"Austria\", \"Ireland\", \"New Zealand\", \"Singapore\", \"Malaysia\", \"Taiwan\",\n  \"Hong Kong\", \"South Africa\", \"Egypt\", \"Morocco\", \"Nigeria\", \"Kenya\",\n  \"Saudi Arabia\", \"United Arab Emirates\", \"Israel\", \"Greece\", \"Czech Republic\",\n  \"Hungary\", \"Romania\", \"Ukraine\", \"Finland\", \"Norway\", \"Denmark\",\n];\n\nexport default function EditProfileScreen() {\n  const insets = useSafeAreaInsets();\n  const headerHeight = useHeaderHeight();\n  const { theme } = useTheme();\n  const { user, token, updateUser, refreshUser } = useAuth();\n  const navigation = useNavigation<NavigationProp>();\n\n  const [name, setName] = useState(user?.name || \"\");\n  const [age, setAge] = useState(user?.age?.toString() || \"\");\n  const [hobbies, setHobbies] = useState(user?.hobbies || \"\");\n  const [topics, setTopics] = useState(user?.topics || \"\");\n  const [country, setCountry] = useState(user?.country || \"\");\n  const [photos, setPhotos] = useState<string[]>(user?.photos || []);\n  const [avatarIndex, setAvatarIndex] = useState(user?.avatarIndex || 0);\n  const [nativeLanguage, setNativeLanguage] = useState(user?.nativeLanguage || \"\");\n  const [learningLanguages, setLearningLanguages] = useState<string[]>(user?.learningLanguages || []);\n  \n  const [isSaving, setIsSaving] = useState(false);\n  const [isUploading, setIsUploading] = useState(false);\n  const [showNativeLanguageModal, setShowNativeLanguageModal] = useState(false);\n  const [showLearningLanguageModal, setShowLearningLanguageModal] = useState(false);\n  const [showCountryModal, setShowCountryModal] = useState(false);\n\n  React.useLayoutEffect(() => {\n    navigation.setOptions({\n      headerLeft: () => (\n        <HeaderButton onPress={() => navigation.goBack()}>\n          <ThemedText>Cancel</ThemedText>\n        </HeaderButton>\n      ),\n      headerRight: () => (\n        <HeaderButton onPress={handleSave} disabled={isSaving}>\n          {isSaving ? (\n            <ActivityIndicator size=\"small\" color={theme.primary} />\n          ) : (\n            <ThemedText style={{ color: theme.primary, fontWeight: \"600\" }}>Save</ThemedText>\n          )}\n        </HeaderButton>\n      ),\n    });\n  }, [navigation, isSaving, name, age, hobbies, topics, country, photos, avatarIndex, nativeLanguage, learningLanguages]);\n\n  const handleSave = async () => {\n    if (!name.trim()) {\n      Alert.alert(\"Error\", \"Please enter your name.\");\n      return;\n    }\n\n    setIsSaving(true);\n    try {\n      await updateUser({\n        name: name.trim(),\n        age: age ? parseInt(age, 10) : undefined,\n        hobbies: hobbies.trim() || undefined,\n        topics: topics.trim() || undefined,\n        country: country.trim() || undefined,\n        photos,\n        avatarIndex,\n        nativeLanguage: nativeLanguage || undefined,\n        learningLanguages: learningLanguages.length > 0 ? learningLanguages : undefined,\n      });\n      navigation.goBack();\n    } catch (error) {\n      Alert.alert(\"Error\", \"Failed to save profile. Please try again.\");\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  const handlePickImage = async (index: number) => {\n    if (Platform.OS === \"web\") {\n      Alert.alert(\"Photo Upload\", \"Photo upload is best experienced in the Expo Go app.\");\n      return;\n    }\n\n    const result = await ImagePicker.launchImageLibraryAsync({\n      mediaTypes: ImagePicker.MediaTypeOptions.Images,\n      allowsEditing: true,\n      aspect: [1, 1],\n      quality: 0.8,\n    });\n\n    if (!result.canceled && result.assets[0]) {\n      setIsUploading(true);\n      try {\n        const asset = result.assets[0];\n        const formData = new FormData();\n        const file = new File(asset.uri);\n        formData.append(\"file\", file);\n\n        const uploadResponse = await fetch(\n          new URL(\"/api/objects/upload\", getApiUrl()).toString(),\n          {\n            method: \"POST\",\n            headers: { Authorization: `Bearer ${token}` },\n            body: formData,\n          }\n        );\n\n        if (!uploadResponse.ok) {\n          throw new Error(\"Upload failed\");\n        }\n\n        const { path } = await uploadResponse.json();\n\n        const newPhotos = [...photos];\n        if (index < photos.length) {\n          newPhotos[index] = path;\n        } else {\n          newPhotos.push(path);\n        }\n        setPhotos(newPhotos);\n        \n        await refreshUser();\n      } catch (error) {\n        Alert.alert(\"Upload Failed\", \"Failed to upload photo. Please try again.\");\n      } finally {\n        setIsUploading(false);\n      }\n    }\n  };\n\n  const handleSetAvatar = (index: number) => {\n    if (index < photos.length) {\n      setAvatarIndex(index);\n    }\n  };\n\n  const getPhotoSource = useCallback((photo: string) => {\n    if (photo.startsWith(\"/avatars/\")) {\n      const avatarMap: Record<string, any> = {\n        \"/avatars/avatar1.png\": require(\"../../assets/avatars/avatar1.png\"),\n        \"/avatars/avatar2.png\": require(\"../../assets/avatars/avatar2.png\"),\n        \"/avatars/avatar3.png\": require(\"../../assets/avatars/avatar3.png\"),\n        \"/avatars/avatar4.png\": require(\"../../assets/avatars/avatar4.png\"),\n        \"/avatars/avatar5.png\": require(\"../../assets/avatars/avatar5.png\"),\n        \"/avatars/avatar6.png\": require(\"../../assets/avatars/avatar6.png\"),\n      };\n      return avatarMap[photo] || require(\"../../assets/avatars/avatar1.png\");\n    }\n    return { uri: new URL(photo.startsWith(\"/objects/\") ? photo : `/objects/${photo}`, getApiUrl()).toString() };\n  }, []);\n\n  const toggleLearningLanguage = (lang: string) => {\n    if (learningLanguages.includes(lang)) {\n      setLearningLanguages(learningLanguages.filter((l) => l !== lang));\n    } else if (learningLanguages.length < 3) {\n      setLearningLanguages([...learningLanguages, lang]);\n    }\n  };\n\n  const renderLanguageModal = (\n    visible: boolean,\n    onClose: () => void,\n    selectedValue: string | string[],\n    onSelect: (lang: string) => void,\n    multiSelect: boolean,\n    title: string\n  ) => (\n    <Modal visible={visible} animationType=\"slide\" transparent>\n      <View style={styles.modalOverlay}>\n        <View style={[styles.modalContent, { backgroundColor: theme.backgroundRoot }]}>\n          <View style={styles.modalHeader}>\n            <ThemedText style={styles.modalTitle}>{title}</ThemedText>\n            <Pressable onPress={onClose}>\n              <Feather name=\"x\" size={24} color={theme.text} />\n            </Pressable>\n          </View>\n          <ScrollView style={styles.languageList}>\n            {LANGUAGES.map((lang) => {\n              const isSelected = multiSelect\n                ? (selectedValue as string[]).includes(lang.name)\n                : selectedValue === lang.name;\n              return (\n                <Pressable\n                  key={lang.code}\n                  style={({ pressed }) => [\n                    styles.languageItem,\n                    isSelected && { backgroundColor: theme.primary + \"20\" },\n                    { opacity: pressed ? 0.8 : 1 },\n                  ]}\n                  onPress={() => onSelect(lang.name)}\n                >\n                  <ThemedText style={styles.languageItemText}>{lang.name}</ThemedText>\n                  {isSelected && <Feather name=\"check\" size={20} color={theme.primary} />}\n                </Pressable>\n              );\n            })}\n          </ScrollView>\n          {multiSelect && (\n            <View style={styles.modalFooter}>\n              <Pressable\n                style={[styles.doneButton, { backgroundColor: theme.primary }]}\n                onPress={onClose}\n              >\n                <ThemedText style={{ color: \"#FFFFFF\", fontWeight: \"600\" }}>Done</ThemedText>\n              </Pressable>\n            </View>\n          )}\n        </View>\n      </View>\n    </Modal>\n  );\n\n  return (\n    <ThemedView style={styles.container}>\n      <KeyboardAwareScrollViewCompat\n        style={{ flex: 1 }}\n        contentContainerStyle={[\n          styles.content,\n          { paddingTop: Spacing.lg, paddingBottom: insets.bottom + Spacing.xl },\n        ]}\n        scrollIndicatorInsets={{ bottom: insets.bottom }}\n      >\n        <ThemedText style={[styles.sectionTitle, { color: theme.textSecondary }]}>\n          Photos\n        </ThemedText>\n        <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.photoScroll}>\n          {Array.from({ length: MAX_PHOTOS }).map((_, index) => {\n            const photo = photos[index];\n            const isAvatar = index === avatarIndex;\n            return (\n              <View key={index} style={styles.photoContainer}>\n                <Pressable\n                  style={({ pressed }) => [\n                    styles.photoSlot,\n                    { backgroundColor: theme.inputBackground, opacity: pressed ? 0.8 : 1 },\n                    isAvatar && { borderColor: theme.primary, borderWidth: 2 },\n                  ]}\n                  onPress={() => (photo ? handleSetAvatar(index) : handlePickImage(index))}\n                  onLongPress={() => handlePickImage(index)}\n                >\n                  {photo ? (\n                    <Image source={getPhotoSource(photo)} style={styles.photoImage} />\n                  ) : isUploading && index === photos.length ? (\n                    <ActivityIndicator color={theme.primary} />\n                  ) : (\n                    <Feather name=\"plus\" size={32} color={theme.textSecondary} />\n                  )}\n                </Pressable>\n                {isAvatar && photo && (\n                  <View style={[styles.avatarBadge, { backgroundColor: theme.primary }]}>\n                    <Feather name=\"star\" size={12} color=\"#FFFFFF\" />\n                  </View>\n                )}\n              </View>\n            );\n          })}\n        </ScrollView>\n        <ThemedText style={[styles.photoHint, { color: theme.textSecondary }]}>\n          Tap to set as avatar. Long press to change photo.\n        </ThemedText>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.textSecondary }]}>\n          Basic Info\n        </ThemedText>\n\n        <View style={styles.inputGroup}>\n          <ThemedText style={[styles.inputLabel, { color: theme.textSecondary }]}>Name</ThemedText>\n          <TextInput\n            style={[styles.input, { backgroundColor: theme.inputBackground, color: theme.text }]}\n            value={name}\n            onChangeText={setName}\n            placeholder=\"Your name\"\n            placeholderTextColor={theme.textSecondary}\n          />\n        </View>\n\n        <View style={styles.inputGroup}>\n          <ThemedText style={[styles.inputLabel, { color: theme.textSecondary }]}>Age</ThemedText>\n          <TextInput\n            style={[styles.input, { backgroundColor: theme.inputBackground, color: theme.text }]}\n            value={age}\n            onChangeText={(text) => setAge(text.replace(/[^0-9]/g, \"\"))}\n            placeholder=\"Your age\"\n            placeholderTextColor={theme.textSecondary}\n            keyboardType=\"number-pad\"\n            maxLength={2}\n          />\n        </View>\n\n        <View style={styles.inputGroup}>\n          <ThemedText style={[styles.inputLabel, { color: theme.textSecondary }]}>Country</ThemedText>\n          <Pressable\n            style={({ pressed }) => [\n              styles.languageSelector,\n              { backgroundColor: theme.inputBackground, opacity: pressed ? 0.8 : 1, marginBottom: 0 },\n            ]}\n            onPress={() => setShowCountryModal(true)}\n          >\n            <ThemedText style={{ color: country ? theme.text : theme.textSecondary }}>\n              {country || \"Select your country\"}\n            </ThemedText>\n            <Feather name=\"chevron-down\" size={20} color={theme.textSecondary} />\n          </Pressable>\n        </View>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.textSecondary }]}>\n          Languages\n        </ThemedText>\n\n        <Pressable\n          style={({ pressed }) => [\n            styles.languageSelector,\n            { backgroundColor: theme.inputBackground, opacity: pressed ? 0.8 : 1 },\n          ]}\n          onPress={() => setShowNativeLanguageModal(true)}\n        >\n          <ThemedText style={{ color: nativeLanguage ? theme.text : theme.textSecondary }}>\n            {nativeLanguage || \"Select native language\"}\n          </ThemedText>\n          <Feather name=\"chevron-down\" size={20} color={theme.textSecondary} />\n        </Pressable>\n\n        <Pressable\n          style={({ pressed }) => [\n            styles.languageSelector,\n            { backgroundColor: theme.inputBackground, opacity: pressed ? 0.8 : 1 },\n          ]}\n          onPress={() => setShowLearningLanguageModal(true)}\n        >\n          <View style={{ flex: 1 }}>\n            {learningLanguages.length > 0 ? (\n              <View style={styles.chipContainer}>\n                {learningLanguages.map((lang) => (\n                  <View key={lang} style={[styles.chip, { backgroundColor: theme.primary + \"20\" }]}>\n                    <ThemedText style={[styles.chipText, { color: theme.primary }]}>{lang}</ThemedText>\n                  </View>\n                ))}\n              </View>\n            ) : (\n              <ThemedText style={{ color: theme.textSecondary }}>Select languages to learn</ThemedText>\n            )}\n          </View>\n          <Feather name=\"chevron-down\" size={20} color={theme.textSecondary} />\n        </Pressable>\n\n        <ThemedText style={[styles.sectionTitle, { color: theme.textSecondary }]}>\n          About You\n        </ThemedText>\n\n        <View style={styles.inputGroup}>\n          <ThemedText style={[styles.inputLabel, { color: theme.textSecondary }]}>Hobbies</ThemedText>\n          <TextInput\n            style={[styles.textArea, { backgroundColor: theme.inputBackground, color: theme.text }]}\n            value={hobbies}\n            onChangeText={setHobbies}\n            placeholder=\"What do you enjoy doing?\"\n            placeholderTextColor={theme.textSecondary}\n            multiline\n            numberOfLines={3}\n            textAlignVertical=\"top\"\n          />\n        </View>\n\n        <View style={styles.inputGroup}>\n          <ThemedText style={[styles.inputLabel, { color: theme.textSecondary }]}>\n            Topics of Interest\n          </ThemedText>\n          <TextInput\n            style={[styles.textArea, { backgroundColor: theme.inputBackground, color: theme.text }]}\n            value={topics}\n            onChangeText={setTopics}\n            placeholder=\"What do you like to talk about?\"\n            placeholderTextColor={theme.textSecondary}\n            multiline\n            numberOfLines={3}\n            textAlignVertical=\"top\"\n          />\n        </View>\n      </KeyboardAwareScrollViewCompat>\n\n      {renderLanguageModal(\n        showNativeLanguageModal,\n        () => setShowNativeLanguageModal(false),\n        nativeLanguage,\n        (lang) => {\n          setNativeLanguage(lang);\n          setShowNativeLanguageModal(false);\n        },\n        false,\n        \"Native Language\"\n      )}\n\n      {renderLanguageModal(\n        showLearningLanguageModal,\n        () => setShowLearningLanguageModal(false),\n        learningLanguages,\n        toggleLearningLanguage,\n        true,\n        \"Languages to Learn (max 3)\"\n      )}\n\n      <Modal visible={showCountryModal} animationType=\"slide\" transparent>\n        <View style={styles.modalOverlay}>\n          <View style={[styles.modalContent, { backgroundColor: theme.backgroundRoot }]}>\n            <View style={styles.modalHeader}>\n              <ThemedText style={styles.modalTitle}>Select Country</ThemedText>\n              <Pressable onPress={() => setShowCountryModal(false)}>\n                <Feather name=\"x\" size={24} color={theme.text} />\n              </Pressable>\n            </View>\n            <ScrollView style={styles.languageList}>\n              {COUNTRIES.map((c) => {\n                const isSelected = country === c;\n                return (\n                  <Pressable\n                    key={c}\n                    style={({ pressed }) => [\n                      styles.languageItem,\n                      isSelected && { backgroundColor: theme.primary + \"20\" },\n                      { opacity: pressed ? 0.8 : 1 },\n                    ]}\n                    onPress={() => {\n                      setCountry(c);\n                      setShowCountryModal(false);\n                    }}\n                  >\n                    <ThemedText style={styles.languageItemText}>{c}</ThemedText>\n                    {isSelected ? <Feather name=\"check\" size={20} color={theme.primary} /> : null}\n                  </Pressable>\n                );\n              })}\n            </ScrollView>\n          </View>\n        </View>\n      </Modal>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  content: {\n    paddingHorizontal: Spacing.xl,\n  },\n  sectionTitle: {\n    ...Typography.small,\n    fontWeight: \"600\",\n    textTransform: \"uppercase\",\n    marginTop: Spacing.xl,\n    marginBottom: Spacing.md,\n  },\n  photoScroll: {\n    marginHorizontal: -Spacing.xl,\n    paddingHorizontal: Spacing.xl,\n  },\n  photoContainer: {\n    position: \"relative\",\n    marginRight: Spacing.md,\n  },\n  photoSlot: {\n    width: 100,\n    height: 100,\n    borderRadius: BorderRadius.sm,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    overflow: \"hidden\",\n  },\n  photoImage: {\n    width: \"100%\",\n    height: \"100%\",\n  },\n  avatarBadge: {\n    position: \"absolute\",\n    top: -4,\n    right: -4,\n    width: 24,\n    height: 24,\n    borderRadius: 12,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  photoHint: {\n    ...Typography.caption,\n    marginTop: Spacing.sm,\n  },\n  inputGroup: {\n    marginBottom: Spacing.lg,\n  },\n  inputLabel: {\n    ...Typography.small,\n    marginBottom: Spacing.sm,\n  },\n  input: {\n    height: Spacing.inputHeight,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    ...Typography.body,\n  },\n  textArea: {\n    minHeight: 100,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n    ...Typography.body,\n  },\n  languageSelector: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    height: Spacing.inputHeight,\n    borderRadius: BorderRadius.xs,\n    paddingHorizontal: Spacing.lg,\n    marginBottom: Spacing.md,\n  },\n  chipContainer: {\n    flexDirection: \"row\",\n    flexWrap: \"wrap\",\n    gap: Spacing.xs,\n  },\n  chip: {\n    paddingHorizontal: Spacing.sm,\n    paddingVertical: Spacing.xs,\n    borderRadius: BorderRadius.full,\n  },\n  chipText: {\n    ...Typography.caption,\n    fontWeight: \"500\",\n  },\n  modalOverlay: {\n    flex: 1,\n    backgroundColor: \"rgba(0,0,0,0.5)\",\n    justifyContent: \"flex-end\",\n  },\n  modalContent: {\n    borderTopLeftRadius: BorderRadius.lg,\n    borderTopRightRadius: BorderRadius.lg,\n    maxHeight: \"70%\",\n  },\n  modalHeader: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    padding: Spacing.xl,\n    borderBottomWidth: 1,\n    borderBottomColor: \"transparent\",\n  },\n  modalTitle: {\n    ...Typography.h4,\n  },\n  languageList: {\n    flex: 1,\n  },\n  languageItem: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"space-between\",\n    padding: Spacing.lg,\n    paddingHorizontal: Spacing.xl,\n  },\n  languageItemText: {\n    ...Typography.body,\n  },\n  modalFooter: {\n    padding: Spacing.xl,\n  },\n  doneButton: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.sm,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n});\n","path":null,"size_bytes":21188,"size_tokens":null},"client/hooks/useScreenOptions.ts":{"content":"import { Platform } from \"react-native\";\nimport { NativeStackNavigationOptions } from \"@react-navigation/native-stack\";\nimport { isLiquidGlassAvailable } from \"expo-glass-effect\";\n\nimport { useTheme } from \"@/hooks/useTheme\";\n\ninterface UseScreenOptionsParams {\n  transparent?: boolean;\n}\n\nexport function useScreenOptions({\n  transparent = true,\n}: UseScreenOptionsParams = {}): NativeStackNavigationOptions {\n  const { theme, isDark } = useTheme();\n\n  return {\n    headerTitleAlign: \"center\",\n    headerTransparent: transparent,\n    headerBlurEffect: isDark ? \"dark\" : \"light\",\n    headerTintColor: theme.text,\n    headerStyle: {\n      backgroundColor: Platform.select({\n        ios: undefined,\n        android: theme.backgroundRoot,\n        web: theme.backgroundRoot,\n      }),\n    },\n    gestureEnabled: true,\n    gestureDirection: \"horizontal\",\n    fullScreenGestureEnabled: isLiquidGlassAvailable() ? false : true,\n    contentStyle: {\n      backgroundColor: theme.backgroundRoot,\n    },\n  };\n}\n","path":null,"size_bytes":1000,"size_tokens":null},"eslint.config.js":{"content":"// https://docs.expo.dev/guides/using-eslint/\nconst { defineConfig } = require(\"eslint/config\");\nconst expoConfig = require(\"eslint-config-expo/flat\");\nconst eslintPluginPrettierRecommended = require(\"eslint-plugin-prettier/recommended\");\n\nmodule.exports = defineConfig([\n  expoConfig,\n  eslintPluginPrettierRecommended,\n  {\n    ignores: [\"dist/*\"],\n  },\n]);\n","path":null,"size_bytes":359,"size_tokens":null},"client/screens/AuthScreen.tsx":{"content":"import React, { useState } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  TextInput,\n  Pressable,\n  ActivityIndicator,\n  Alert,\n  Image,\n} from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { KeyboardAwareScrollViewCompat } from \"@/components/KeyboardAwareScrollViewCompat\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useAuth } from \"@/contexts/AuthContext\";\nimport { Colors, Spacing, BorderRadius, Typography } from \"@/constants/theme\";\nimport { Feather } from \"@expo/vector-icons\";\n\nexport default function AuthScreen() {\n  const insets = useSafeAreaInsets();\n  const { theme, isDark } = useTheme();\n  const { login, register } = useAuth();\n\n  const [isLogin, setIsLogin] = useState(true);\n  const [email, setEmail] = useState(\"\");\n  const [password, setPassword] = useState(\"\");\n  const [name, setName] = useState(\"\");\n  const [showPassword, setShowPassword] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n\n  const handleSubmit = async () => {\n    if (!email.trim() || !password.trim()) {\n      Alert.alert(\"Error\", \"Please fill in all fields\");\n      return;\n    }\n\n    if (!isLogin && !name.trim()) {\n      Alert.alert(\"Error\", \"Please enter your name\");\n      return;\n    }\n\n    if (password.length < 6) {\n      Alert.alert(\"Error\", \"Password must be at least 6 characters\");\n      return;\n    }\n\n    setIsLoading(true);\n    try {\n      if (isLogin) {\n        await login(email.trim(), password);\n      } else {\n        await register(email.trim(), password, name.trim());\n      }\n    } catch (error: any) {\n      Alert.alert(\"Error\", error.message || \"Something went wrong\");\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <ThemedView style={styles.container}>\n      <KeyboardAwareScrollViewCompat\n        contentContainerStyle={[\n          styles.content,\n          { paddingTop: insets.top + Spacing[\"3xl\"], paddingBottom: insets.bottom + Spacing.xl },\n        ]}\n      >\n        <View style={styles.header}>\n          <Image\n            source={require(\"../../assets/images/icon.png\")}\n            style={styles.logo}\n          />\n          <ThemedText style={[styles.title, { color: theme.primary }]}>\n            Welcome to LanChat\n          </ThemedText>\n          <ThemedText style={[styles.subtitle, { color: theme.textSecondary }]}>\n            Connect with language learners worldwide\n          </ThemedText>\n        </View>\n\n        <View style={styles.form}>\n          {!isLogin && (\n            <View style={[styles.inputContainer, { backgroundColor: theme.inputBackground, borderColor: theme.border }]}>\n              <Feather name=\"user\" size={20} color={theme.textSecondary} style={styles.inputIcon} />\n              <TextInput\n                style={[styles.input, { color: theme.text }]}\n                placeholder=\"Your name\"\n                placeholderTextColor={theme.textSecondary}\n                value={name}\n                onChangeText={setName}\n                autoCapitalize=\"words\"\n              />\n            </View>\n          )}\n\n          <View style={[styles.inputContainer, { backgroundColor: theme.inputBackground, borderColor: theme.border }]}>\n            <Feather name=\"mail\" size={20} color={theme.textSecondary} style={styles.inputIcon} />\n            <TextInput\n              style={[styles.input, { color: theme.text }]}\n              placeholder=\"Email address\"\n              placeholderTextColor={theme.textSecondary}\n              value={email}\n              onChangeText={setEmail}\n              keyboardType=\"email-address\"\n              autoCapitalize=\"none\"\n              autoComplete=\"email\"\n            />\n          </View>\n\n          <View style={[styles.inputContainer, { backgroundColor: theme.inputBackground, borderColor: theme.border }]}>\n            <Feather name=\"lock\" size={20} color={theme.textSecondary} style={styles.inputIcon} />\n            <TextInput\n              style={[styles.input, { color: theme.text }]}\n              placeholder=\"Password\"\n              placeholderTextColor={theme.textSecondary}\n              value={password}\n              onChangeText={setPassword}\n              secureTextEntry={!showPassword}\n              autoCapitalize=\"none\"\n            />\n            <Pressable onPress={() => setShowPassword(!showPassword)} style={styles.eyeButton}>\n              <Feather name={showPassword ? \"eye-off\" : \"eye\"} size={20} color={theme.textSecondary} />\n            </Pressable>\n          </View>\n\n          <Pressable\n            style={({ pressed }) => [\n              styles.submitButton,\n              { backgroundColor: theme.primary, opacity: pressed ? 0.9 : 1 },\n            ]}\n            onPress={handleSubmit}\n            disabled={isLoading}\n          >\n            {isLoading ? (\n              <ActivityIndicator color=\"#FFFFFF\" />\n            ) : (\n              <ThemedText style={styles.submitButtonText}>\n                {isLogin ? \"Sign In\" : \"Create Account\"}\n              </ThemedText>\n            )}\n          </Pressable>\n\n          <Pressable onPress={() => setIsLogin(!isLogin)} style={styles.switchButton}>\n            <ThemedText style={[styles.switchText, { color: theme.textSecondary }]}>\n              {isLogin ? \"Don't have an account? \" : \"Already have an account? \"}\n              <ThemedText style={{ color: theme.primary, fontWeight: \"600\" }}>\n                {isLogin ? \"Create Account\" : \"Sign In\"}\n              </ThemedText>\n            </ThemedText>\n          </Pressable>\n        </View>\n      </KeyboardAwareScrollViewCompat>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  content: {\n    flexGrow: 1,\n    paddingHorizontal: Spacing.xl,\n    justifyContent: \"center\",\n  },\n  header: {\n    alignItems: \"center\",\n    marginBottom: Spacing[\"4xl\"],\n  },\n  logo: {\n    width: 100,\n    height: 100,\n    borderRadius: BorderRadius.lg,\n    marginBottom: Spacing.xl,\n  },\n  title: {\n    ...Typography.h2,\n    marginBottom: Spacing.sm,\n    textAlign: \"center\",\n  },\n  subtitle: {\n    ...Typography.body,\n    textAlign: \"center\",\n  },\n  form: {\n    gap: Spacing.lg,\n  },\n  inputContainer: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    borderWidth: 1,\n    borderRadius: BorderRadius.sm,\n    height: Spacing.inputHeight,\n    paddingHorizontal: Spacing.lg,\n  },\n  inputIcon: {\n    marginRight: Spacing.md,\n  },\n  input: {\n    flex: 1,\n    ...Typography.body,\n    height: \"100%\",\n  },\n  eyeButton: {\n    padding: Spacing.xs,\n  },\n  submitButton: {\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.sm,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    marginTop: Spacing.sm,\n  },\n  submitButtonText: {\n    color: \"#FFFFFF\",\n    ...Typography.body,\n    fontWeight: \"600\",\n  },\n  switchButton: {\n    alignItems: \"center\",\n    paddingVertical: Spacing.md,\n  },\n  switchText: {\n    ...Typography.body,\n  },\n});\n","path":null,"size_bytes":7025,"size_tokens":null},"server/storage.ts":{"content":"import { users, messages, blockedUsers, reports, type User, type InsertUser, type Message, type BlockedUser, type Report } from \"@shared/schema\";\nimport { db } from \"./db\";\nimport { eq, and, or, desc, sql, ne, notInArray, gte } from \"drizzle-orm\";\nimport { hash, compare } from \"./auth\";\n\nexport interface UserFilters {\n  excludeId?: string;\n  isOnline?: boolean;\n  isNew?: boolean;\n  minAge?: number;\n  maxAge?: number;\n  nativeLanguage?: string;\n  learningLanguage?: string;\n  country?: string;\n  hobbies?: string;\n  topics?: string;\n  verifiedOnly?: boolean;\n}\n\nexport interface IStorage {\n  getUser(id: string): Promise<User | undefined>;\n  getUserByEmail(email: string): Promise<User | undefined>;\n  createUser(user: InsertUser): Promise<User>;\n  updateUser(id: string, data: Partial<User>): Promise<User | undefined>;\n  getUsers(filters?: UserFilters): Promise<User[]>;\n  \n  getMessages(userId1: string, userId2: string): Promise<Message[]>;\n  createMessage(senderId: string, receiverId: string, content: string): Promise<Message>;\n  getConversations(userId: string): Promise<{ user: User; lastMessage: Message }[]>;\n  reportMessage(messageId: string, reporterId: string, reason?: string): Promise<Report>;\n  \n  blockUser(blockerId: string, blockedId: string): Promise<BlockedUser>;\n  unblockUser(blockerId: string, blockedId: string): Promise<void>;\n  getBlockedUsers(userId: string): Promise<string[]>;\n  isBlocked(userId: string, targetId: string): Promise<boolean>;\n  \n  reportUser(reporterId: string, reportedId: string, reason?: string): Promise<Report>;\n  \n  seedBotUsers(): Promise<void>;\n}\n\nexport class DatabaseStorage implements IStorage {\n  async getUser(id: string): Promise<User | undefined> {\n    const [user] = await db.select().from(users).where(eq(users.id, id));\n    return user || undefined;\n  }\n\n  async getUserByEmail(email: string): Promise<User | undefined> {\n    const [user] = await db.select().from(users).where(eq(users.email, email.toLowerCase()));\n    return user || undefined;\n  }\n\n  async createUser(insertUser: InsertUser): Promise<User> {\n    const hashedPassword = await hash(insertUser.password);\n    const [user] = await db\n      .insert(users)\n      .values({\n        ...insertUser,\n        email: insertUser.email.toLowerCase(),\n        password: hashedPassword,\n      })\n      .returning();\n    return user;\n  }\n\n  async updateUser(id: string, data: Partial<User>): Promise<User | undefined> {\n    const [user] = await db\n      .update(users)\n      .set(data)\n      .where(eq(users.id, id))\n      .returning();\n    return user || undefined;\n  }\n\n  async getUsers(filters?: UserFilters): Promise<User[]> {\n    let query = db.select().from(users);\n    \n    const conditions = [];\n    \n    if (filters?.excludeId) {\n      const blockedIds = await this.getBlockedUsers(filters.excludeId);\n      const blockedByIds = await this.getBlockedByUsers(filters.excludeId);\n      const allBlockedIds = [...blockedIds, ...blockedByIds];\n      \n      conditions.push(ne(users.id, filters.excludeId));\n      if (allBlockedIds.length > 0) {\n        conditions.push(notInArray(users.id, allBlockedIds));\n      }\n    }\n    \n    if (filters?.isOnline !== undefined) {\n      conditions.push(eq(users.isOnline, filters.isOnline));\n    }\n    \n    if (filters?.isNew) {\n      const oneWeekAgo = new Date();\n      oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);\n      conditions.push(gte(users.createdAt, oneWeekAgo));\n    }\n    \n    if (filters?.minAge !== undefined) {\n      conditions.push(or(sql`${users.age} IS NULL`, gte(users.age, filters.minAge)));\n    }\n    \n    if (filters?.maxAge !== undefined) {\n      conditions.push(or(sql`${users.age} IS NULL`, sql`${users.age} <= ${filters.maxAge}`));\n    }\n    \n    if (filters?.nativeLanguage) {\n      conditions.push(sql`LOWER(${users.nativeLanguage}) = LOWER(${filters.nativeLanguage})`);\n    }\n    \n    if (filters?.learningLanguage) {\n      conditions.push(sql`${users.learningLanguages}::jsonb @> ${JSON.stringify([filters.learningLanguage])}::jsonb`);\n    }\n    \n    if (filters?.country) {\n      conditions.push(sql`LOWER(${users.country}) = LOWER(${filters.country})`);\n    }\n    \n    if (filters?.hobbies) {\n      conditions.push(sql`LOWER(${users.hobbies}) LIKE LOWER(${'%' + filters.hobbies + '%'})`);\n    }\n    \n    if (filters?.topics) {\n      conditions.push(sql`LOWER(${users.topics}) LIKE LOWER(${'%' + filters.topics + '%'})`);\n    }\n    \n    if (filters?.verifiedOnly) {\n      conditions.push(eq(users.isVerified, true));\n    }\n    \n    if (conditions.length > 0) {\n      query = query.where(and(...conditions)) as typeof query;\n    }\n    \n    return query.orderBy(desc(users.isOnline), desc(users.lastSeen));\n  }\n\n  async getMessages(userId1: string, userId2: string): Promise<Message[]> {\n    return db.select().from(messages).where(\n      or(\n        and(eq(messages.senderId, userId1), eq(messages.receiverId, userId2)),\n        and(eq(messages.senderId, userId2), eq(messages.receiverId, userId1))\n      )\n    ).orderBy(messages.createdAt);\n  }\n\n  async createMessage(senderId: string, receiverId: string, content: string): Promise<Message> {\n    const [message] = await db.insert(messages).values({\n      senderId,\n      receiverId,\n      content,\n    }).returning();\n    return message;\n  }\n\n  async getConversations(userId: string): Promise<{ user: User; lastMessage: Message }[]> {\n    const allMessages = await db.select().from(messages).where(\n      or(\n        eq(messages.senderId, userId),\n        eq(messages.receiverId, userId)\n      )\n    ).orderBy(desc(messages.createdAt));\n\n    const conversationMap = new Map<string, Message>();\n    \n    for (const msg of allMessages) {\n      const otherUserId = msg.senderId === userId ? msg.receiverId : msg.senderId;\n      if (!conversationMap.has(otherUserId)) {\n        conversationMap.set(otherUserId, msg);\n      }\n    }\n\n    const conversations: { user: User; lastMessage: Message }[] = [];\n    \n    for (const [otherUserId, lastMessage] of conversationMap) {\n      const user = await this.getUser(otherUserId);\n      if (user) {\n        const isBlocked = await this.isBlocked(userId, otherUserId);\n        if (!isBlocked) {\n          conversations.push({ user, lastMessage });\n        }\n      }\n    }\n\n    return conversations.sort((a, b) => \n      new Date(b.lastMessage.createdAt!).getTime() - new Date(a.lastMessage.createdAt!).getTime()\n    );\n  }\n\n  async reportMessage(messageId: string, reporterId: string, reason?: string): Promise<Report> {\n    const [message] = await db.select().from(messages).where(eq(messages.id, messageId));\n    if (!message) {\n      throw new Error(\"Message not found\");\n    }\n\n    await db.update(messages).set({ isReported: true }).where(eq(messages.id, messageId));\n\n    const [report] = await db.insert(reports).values({\n      reporterId,\n      reportedId: message.senderId,\n      messageId,\n      reason,\n      type: \"message\",\n    }).returning();\n    \n    return report;\n  }\n\n  async blockUser(blockerId: string, blockedId: string): Promise<BlockedUser> {\n    const existing = await db.select().from(blockedUsers).where(\n      and(eq(blockedUsers.blockerId, blockerId), eq(blockedUsers.blockedId, blockedId))\n    );\n    \n    if (existing.length > 0) {\n      return existing[0];\n    }\n\n    const [blocked] = await db.insert(blockedUsers).values({\n      blockerId,\n      blockedId,\n    }).returning();\n    return blocked;\n  }\n\n  async unblockUser(blockerId: string, blockedId: string): Promise<void> {\n    await db.delete(blockedUsers).where(\n      and(eq(blockedUsers.blockerId, blockerId), eq(blockedUsers.blockedId, blockedId))\n    );\n  }\n\n  async getBlockedUsers(userId: string): Promise<string[]> {\n    const blocked = await db.select().from(blockedUsers).where(eq(blockedUsers.blockerId, userId));\n    return blocked.map(b => b.blockedId);\n  }\n\n  async getBlockedByUsers(userId: string): Promise<string[]> {\n    const blocked = await db.select().from(blockedUsers).where(eq(blockedUsers.blockedId, userId));\n    return blocked.map(b => b.blockerId);\n  }\n\n  async isBlocked(userId: string, targetId: string): Promise<boolean> {\n    const blocked = await db.select().from(blockedUsers).where(\n      or(\n        and(eq(blockedUsers.blockerId, userId), eq(blockedUsers.blockedId, targetId)),\n        and(eq(blockedUsers.blockerId, targetId), eq(blockedUsers.blockedId, userId))\n      )\n    );\n    return blocked.length > 0;\n  }\n\n  async reportUser(reporterId: string, reportedId: string, reason?: string): Promise<Report> {\n    const [report] = await db.insert(reports).values({\n      reporterId,\n      reportedId,\n      reason,\n      type: \"profile\",\n    }).returning();\n    return report;\n  }\n\n  async seedBotUsers(): Promise<void> {\n    const existingBots = await db.select().from(users).where(eq(users.isBot, true));\n    if (existingBots.length > 0) {\n      return;\n    }\n\n    const botUsers = [\n      {\n        email: \"sofia@lanchat.bot\",\n        password: \"botpassword123\",\n        name: \"Sofia Martinez\",\n        age: 28,\n        nativeLanguage: \"Spanish\",\n        learningLanguages: [\"English\", \"French\"],\n        hobbies: \"Photography, hiking, cooking traditional recipes\",\n        topics: \"Travel, culture, food, music\",\n        photos: [\"/avatars/avatar1.png\"],\n        avatarIndex: 0,\n        isOnline: true,\n        isBot: true,\n      },\n      {\n        email: \"james@lanchat.bot\",\n        password: \"botpassword123\",\n        name: \"James Wilson\",\n        age: 32,\n        nativeLanguage: \"English\",\n        learningLanguages: [\"Japanese\", \"Korean\"],\n        hobbies: \"Gaming, anime, martial arts\",\n        topics: \"Technology, gaming, movies, sports\",\n        photos: [\"/avatars/avatar2.png\"],\n        avatarIndex: 0,\n        isOnline: true,\n        isBot: true,\n      },\n      {\n        email: \"maria@lanchat.bot\",\n        password: \"botpassword123\",\n        name: \"Maria Chen\",\n        age: 35,\n        nativeLanguage: \"Chinese\",\n        learningLanguages: [\"English\", \"Spanish\"],\n        hobbies: \"Reading, yoga, painting\",\n        topics: \"Art, literature, wellness, business\",\n        photos: [\"/avatars/avatar3.png\"],\n        avatarIndex: 0,\n        isOnline: false,\n        isBot: true,\n      },\n      {\n        email: \"yuki@lanchat.bot\",\n        password: \"botpassword123\",\n        name: \"Yuki Tanaka\",\n        age: 25,\n        nativeLanguage: \"Japanese\",\n        learningLanguages: [\"English\", \"German\"],\n        hobbies: \"Music, piano, coffee brewing\",\n        topics: \"Music, fashion, lifestyle, anime\",\n        photos: [\"/avatars/avatar4.png\"],\n        avatarIndex: 0,\n        isOnline: true,\n        isBot: true,\n      },\n      {\n        email: \"amara@lanchat.bot\",\n        password: \"botpassword123\",\n        name: \"Amara Johnson\",\n        age: 29,\n        nativeLanguage: \"English\",\n        learningLanguages: [\"French\", \"Portuguese\"],\n        hobbies: \"Dancing, fitness, traveling\",\n        topics: \"Dance, health, travel, culture\",\n        photos: [\"/avatars/avatar5.png\"],\n        avatarIndex: 0,\n        isOnline: true,\n        isBot: true,\n      },\n      {\n        email: \"carlos@lanchat.bot\",\n        password: \"botpassword123\",\n        name: \"Carlos Rodriguez\",\n        age: 31,\n        nativeLanguage: \"Portuguese\",\n        learningLanguages: [\"English\", \"Italian\"],\n        hobbies: \"Soccer, cooking, surfing\",\n        topics: \"Sports, food, beach life, music\",\n        photos: [\"/avatars/avatar6.png\"],\n        avatarIndex: 0,\n        isOnline: false,\n        isBot: true,\n      },\n    ];\n\n    for (const bot of botUsers) {\n      const hashedPassword = await hash(bot.password);\n      await db.insert(users).values({\n        ...bot,\n        password: hashedPassword,\n      });\n    }\n  }\n}\n\nexport const storage = new DatabaseStorage();\n","path":null,"size_bytes":11768,"size_tokens":null},"client/components/ErrorBoundary.tsx":{"content":"import React, { Component, ComponentType, PropsWithChildren } from \"react\";\nimport { ErrorFallback, ErrorFallbackProps } from \"@/components/ErrorFallback\";\n\nexport type ErrorBoundaryProps = PropsWithChildren<{\n  FallbackComponent?: ComponentType<ErrorFallbackProps>;\n  onError?: (error: Error, stackTrace: string) => void;\n}>;\n\ntype ErrorBoundaryState = { error: Error | null };\n\n/**\n * This is a special case for for using the class components. Error boundaries must be class components because React only provides error boundary functionality through lifecycle methods (componentDidCatch and getDerivedStateFromError) which are not available in functional components.\n * https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary\n */\n\nexport class ErrorBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  state: ErrorBoundaryState = { error: null };\n\n  static defaultProps: {\n    FallbackComponent: ComponentType<ErrorFallbackProps>;\n  } = {\n    FallbackComponent: ErrorFallback,\n  };\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { error };\n  }\n\n  componentDidCatch(error: Error, info: { componentStack: string }): void {\n    if (typeof this.props.onError === \"function\") {\n      this.props.onError(error, info.componentStack);\n    }\n  }\n\n  resetError = (): void => {\n    this.setState({ error: null });\n  };\n\n  render() {\n    const { FallbackComponent } = this.props;\n\n    return this.state.error && FallbackComponent ? (\n      <FallbackComponent\n        error={this.state.error}\n        resetError={this.resetError}\n      />\n    ) : (\n      this.props.children\n    );\n  }\n}\n","path":null,"size_bytes":1674,"size_tokens":null},"server/auth.ts":{"content":"import { randomBytes, scrypt, timingSafeEqual } from \"crypto\";\nimport { promisify } from \"util\";\nimport type { Request, Response, NextFunction } from \"express\";\nimport { sign, verify } from \"jsonwebtoken\";\n\nconst scryptAsync = promisify(scrypt);\n\nconst JWT_SECRET = process.env.SESSION_SECRET || \"lanchat-secret-key-change-in-production\";\n\nexport async function hash(password: string): Promise<string> {\n  const salt = randomBytes(16).toString(\"hex\");\n  const derivedKey = (await scryptAsync(password, salt, 64)) as Buffer;\n  return `${salt}:${derivedKey.toString(\"hex\")}`;\n}\n\nexport async function compare(password: string, storedHash: string): Promise<boolean> {\n  const [salt, hashKey] = storedHash.split(\":\");\n  const derivedKey = (await scryptAsync(password, salt, 64)) as Buffer;\n  const storedKey = Buffer.from(hashKey, \"hex\");\n  return timingSafeEqual(derivedKey, storedKey);\n}\n\nexport function generateToken(userId: string): string {\n  return sign({ userId }, JWT_SECRET, { expiresIn: \"7d\" });\n}\n\nexport function verifyToken(token: string): { userId: string } | null {\n  try {\n    return verify(token, JWT_SECRET) as { userId: string };\n  } catch {\n    return null;\n  }\n}\n\nexport interface AuthenticatedRequest extends Request {\n  userId?: string;\n}\n\nexport function authMiddleware(req: AuthenticatedRequest, res: Response, next: NextFunction) {\n  const authHeader = req.headers.authorization;\n  \n  if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n    return res.status(401).json({ error: \"Unauthorized\" });\n  }\n  \n  const token = authHeader.substring(7);\n  const decoded = verifyToken(token);\n  \n  if (!decoded) {\n    return res.status(401).json({ error: \"Invalid token\" });\n  }\n  \n  req.userId = decoded.userId;\n  next();\n}\n","path":null,"size_bytes":1742,"size_tokens":null},"client/contexts/PresenceContext.tsx":{"content":"import React, { createContext, useContext, useEffect, useState, useCallback, useRef, type ReactNode } from 'react';\nimport { AppState, type AppStateStatus } from 'react-native';\nimport { useAuth } from './AuthContext';\nimport { getApiUrl } from '@/lib/query-client';\n\ninterface PresenceContextType {\n  onlineUsers: Set<string>;\n  isConnected: boolean;\n  isUserOnline: (userId: string) => boolean;\n}\n\nconst PresenceContext = createContext<PresenceContextType | undefined>(undefined);\n\nconst RECONNECT_DELAY_MS = 3000;\nconst MAX_RECONNECT_ATTEMPTS = 5;\n\nexport function PresenceProvider({ children }: { children: ReactNode }) {\n  const { token, isAuthenticated } = useAuth();\n  const [onlineUsers, setOnlineUsers] = useState<Set<string>>(new Set());\n  const [isConnected, setIsConnected] = useState(false);\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const reconnectAttemptsRef = useRef(0);\n  const appStateRef = useRef<AppStateStatus>(AppState.currentState);\n  const shouldReconnectRef = useRef(true);\n\n  const getWebSocketUrl = useCallback(() => {\n    const apiUrl = getApiUrl();\n    const url = new URL(apiUrl);\n    const wsProtocol = url.protocol === 'https:' ? 'wss:' : 'ws:';\n    return `${wsProtocol}//${url.host}/ws?token=${token}`;\n  }, [token]);\n\n  const connect = useCallback(() => {\n    if (!token || !isAuthenticated) {\n      return;\n    }\n\n    if (wsRef.current?.readyState === WebSocket.OPEN || \n        wsRef.current?.readyState === WebSocket.CONNECTING) {\n      return;\n    }\n\n    shouldReconnectRef.current = true;\n\n    try {\n      const wsUrl = getWebSocketUrl();\n      const ws = new WebSocket(wsUrl);\n\n      ws.onopen = () => {\n        setIsConnected(true);\n        reconnectAttemptsRef.current = 0;\n        if (reconnectTimeoutRef.current) {\n          clearTimeout(reconnectTimeoutRef.current);\n          reconnectTimeoutRef.current = null;\n        }\n      };\n\n      ws.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n          \n          if (data.type === 'presence') {\n            setOnlineUsers(new Set(data.onlineUsers || []));\n          } else if (data.type === 'user_status') {\n            setOnlineUsers(prev => {\n              const updated = new Set(prev);\n              if (data.isOnline) {\n                updated.add(data.userId);\n              } else {\n                updated.delete(data.userId);\n              }\n              return updated;\n            });\n          }\n        } catch (error) {\n          console.error('Failed to parse WebSocket message:', error);\n        }\n      };\n\n      ws.onclose = () => {\n        setIsConnected(false);\n        wsRef.current = null;\n        \n        if (shouldReconnectRef.current && \n            isAuthenticated && \n            appStateRef.current === 'active' &&\n            reconnectAttemptsRef.current < MAX_RECONNECT_ATTEMPTS) {\n          reconnectAttemptsRef.current++;\n          const delay = RECONNECT_DELAY_MS * Math.pow(1.5, reconnectAttemptsRef.current - 1);\n          reconnectTimeoutRef.current = setTimeout(() => {\n            connect();\n          }, delay);\n        }\n      };\n\n      ws.onerror = (error) => {\n        console.error('WebSocket error:', error);\n      };\n\n      wsRef.current = ws;\n    } catch (error) {\n      console.error('Failed to connect WebSocket:', error);\n    }\n  }, [token, isAuthenticated, getWebSocketUrl]);\n\n  const disconnect = useCallback(() => {\n    shouldReconnectRef.current = false;\n    \n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n    \n    if (wsRef.current) {\n      wsRef.current.close();\n      wsRef.current = null;\n    }\n    \n    setIsConnected(false);\n    setOnlineUsers(new Set());\n    reconnectAttemptsRef.current = 0;\n  }, []);\n\n  useEffect(() => {\n    if (isAuthenticated && token) {\n      connect();\n    } else {\n      disconnect();\n    }\n\n    return () => {\n      disconnect();\n    };\n  }, [isAuthenticated, token, connect, disconnect]);\n\n  useEffect(() => {\n    const subscription = AppState.addEventListener('change', (nextAppState) => {\n      if (appStateRef.current.match(/inactive|background/) && nextAppState === 'active') {\n        if (isAuthenticated && (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN)) {\n          reconnectAttemptsRef.current = 0;\n          connect();\n        }\n      }\n      appStateRef.current = nextAppState;\n    });\n\n    return () => {\n      subscription.remove();\n    };\n  }, [isAuthenticated, connect]);\n\n  const isUserOnline = useCallback((userId: string) => {\n    return onlineUsers.has(userId);\n  }, [onlineUsers]);\n\n  return (\n    <PresenceContext.Provider value={{ onlineUsers, isConnected, isUserOnline }}>\n      {children}\n    </PresenceContext.Provider>\n  );\n}\n\nexport function usePresence() {\n  const context = useContext(PresenceContext);\n  if (context === undefined) {\n    throw new Error('usePresence must be used within a PresenceProvider');\n  }\n  return context;\n}\n","path":null,"size_bytes":5079,"size_tokens":null},"client/App.tsx":{"content":"import React from \"react\";\nimport { StyleSheet } from \"react-native\";\nimport { NavigationContainer } from \"@react-navigation/native\";\nimport { GestureHandlerRootView } from \"react-native-gesture-handler\";\nimport { KeyboardProvider } from \"react-native-keyboard-controller\";\nimport { SafeAreaProvider } from \"react-native-safe-area-context\";\nimport { StatusBar } from \"expo-status-bar\";\n\nimport { QueryClientProvider } from \"@tanstack/react-query\";\nimport { queryClient } from \"@/lib/query-client\";\n\nimport RootStackNavigator from \"@/navigation/RootStackNavigator\";\nimport { ErrorBoundary } from \"@/components/ErrorBoundary\";\nimport { AuthProvider } from \"@/contexts/AuthContext\";\nimport { PresenceProvider } from \"@/contexts/PresenceContext\";\nimport { NotificationProvider } from \"@/contexts/NotificationContext\";\n\nexport default function App() {\n  return (\n    <ErrorBoundary>\n      <QueryClientProvider client={queryClient}>\n        <AuthProvider>\n          <NotificationProvider>\n            <PresenceProvider>\n              <SafeAreaProvider>\n                <GestureHandlerRootView style={styles.root}>\n                  <KeyboardProvider>\n                    <NavigationContainer>\n                      <RootStackNavigator />\n                    </NavigationContainer>\n                    <StatusBar style=\"auto\" />\n                  </KeyboardProvider>\n                </GestureHandlerRootView>\n              </SafeAreaProvider>\n            </PresenceProvider>\n          </NotificationProvider>\n        </AuthProvider>\n      </QueryClientProvider>\n    </ErrorBoundary>\n  );\n}\n\nconst styles = StyleSheet.create({\n  root: {\n    flex: 1,\n  },\n});\n","path":null,"size_bytes":1651,"size_tokens":null},"client/hooks/useColorScheme.ts":{"content":"export { useColorScheme } from \"react-native\";\n","path":null,"size_bytes":47,"size_tokens":null},"client/screens/CommunityScreen.tsx":{"content":"import React, { useState, useCallback, useMemo } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  FlatList,\n  Pressable,\n  Image,\n  ActivityIndicator,\n  Modal,\n  RefreshControl,\n  TextInput,\n  ScrollView,\n} from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useBottomTabBarHeight } from \"@react-navigation/bottom-tabs\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { VerificationBadge } from \"@/components/VerificationBadge\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useAuth } from \"@/contexts/AuthContext\";\nimport { usePresence } from \"@/contexts/PresenceContext\";\nimport { Colors, Spacing, BorderRadius, Typography } from \"@/constants/theme\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { getApiUrl } from \"@/lib/query-client\";\nimport type { User } from \"@shared/schema\";\nimport type { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport type { RootStackParamList } from \"@/navigation/RootStackNavigator\";\n\ntype NavigationProp = NativeStackNavigationProp<RootStackParamList>;\n\nconst LANGUAGES = [\n  \"English\", \"Spanish\", \"French\", \"German\", \"Italian\", \"Portuguese\",\n  \"Chinese\", \"Japanese\", \"Korean\", \"Arabic\", \"Russian\", \"Hindi\",\n  \"Dutch\", \"Swedish\", \"Polish\", \"Turkish\", \"Vietnamese\", \"Thai\",\n];\n\nconst COUNTRIES = [\n  \"United States\", \"United Kingdom\", \"Canada\", \"Australia\", \"Spain\",\n  \"France\", \"Germany\", \"Italy\", \"Brazil\", \"Mexico\", \"Japan\", \"China\",\n  \"South Korea\", \"India\", \"Russia\", \"Netherlands\", \"Sweden\", \"Poland\",\n  \"Turkey\", \"Vietnam\", \"Thailand\", \"Indonesia\", \"Philippines\", \"Argentina\",\n];\n\ninterface AdvancedFilters {\n  nativeLanguage: string;\n  learningLanguage: string;\n  country: string;\n  hobbies: string;\n  topics: string;\n  minAge: number;\n  maxAge: number;\n  verifiedOnly: boolean;\n}\n\nconst defaultFilters: AdvancedFilters = {\n  nativeLanguage: \"\",\n  learningLanguage: \"\",\n  country: \"\",\n  hobbies: \"\",\n  topics: \"\",\n  minAge: 18,\n  maxAge: 65,\n  verifiedOnly: false,\n};\n\nexport default function CommunityScreen() {\n  const insets = useSafeAreaInsets();\n  const tabBarHeight = useBottomTabBarHeight();\n  const { theme } = useTheme();\n  const { token } = useAuth();\n  const { isUserOnline } = usePresence();\n  const navigation = useNavigation<NavigationProp>();\n\n  const [filter, setFilter] = useState<\"all\" | \"new\" | \"online\">(\"all\");\n  const [showAdvancedFilters, setShowAdvancedFilters] = useState(false);\n  const [advancedFilters, setAdvancedFilters] = useState<AdvancedFilters>(defaultFilters);\n  const [tempFilters, setTempFilters] = useState<AdvancedFilters>(defaultFilters);\n\n  const hasActiveFilters = useMemo(() => {\n    return (\n      advancedFilters.nativeLanguage !== \"\" ||\n      advancedFilters.learningLanguage !== \"\" ||\n      advancedFilters.country !== \"\" ||\n      advancedFilters.hobbies !== \"\" ||\n      advancedFilters.topics !== \"\" ||\n      advancedFilters.minAge !== 18 ||\n      advancedFilters.maxAge !== 65 ||\n      advancedFilters.verifiedOnly\n    );\n  }, [advancedFilters]);\n\n  const buildQueryParams = useCallback(() => {\n    const params = new URLSearchParams();\n    if (filter === \"online\") params.append(\"online\", \"true\");\n    if (filter === \"new\") params.append(\"newMembers\", \"true\");\n    if (advancedFilters.minAge > 18) params.append(\"minAge\", advancedFilters.minAge.toString());\n    if (advancedFilters.maxAge < 65) params.append(\"maxAge\", advancedFilters.maxAge.toString());\n    if (advancedFilters.nativeLanguage) params.append(\"nativeLanguage\", advancedFilters.nativeLanguage);\n    if (advancedFilters.learningLanguage) params.append(\"learningLanguage\", advancedFilters.learningLanguage);\n    if (advancedFilters.country) params.append(\"country\", advancedFilters.country);\n    if (advancedFilters.hobbies) params.append(\"hobbies\", advancedFilters.hobbies);\n    if (advancedFilters.topics) params.append(\"topics\", advancedFilters.topics);\n    if (advancedFilters.verifiedOnly) params.append(\"verifiedOnly\", \"true\");\n    return params.toString();\n  }, [filter, advancedFilters]);\n\n  const { data: users = [], isLoading, refetch, isRefetching } = useQuery<User[]>({\n    queryKey: [\"/api/users\", filter, JSON.stringify(advancedFilters)],\n    queryFn: async () => {\n      const queryParams = buildQueryParams();\n      const url = new URL(`/api/users${queryParams ? `?${queryParams}` : \"\"}`, getApiUrl());\n      const response = await fetch(url.toString(), {\n        headers: { Authorization: `Bearer ${token}` },\n      });\n      if (!response.ok) throw new Error(\"Failed to fetch users\");\n      return response.json();\n    },\n  });\n\n  const getAvatarSource = useCallback((user: User) => {\n    const photos = user.photos || [];\n    const avatarIndex = user.avatarIndex || 0;\n    const photo = photos[avatarIndex] || photos[0];\n    \n    if (photo) {\n      if (photo.startsWith(\"/avatars/\")) {\n        const avatarMap: Record<string, any> = {\n          \"/avatars/avatar1.png\": require(\"../../assets/avatars/avatar1.png\"),\n          \"/avatars/avatar2.png\": require(\"../../assets/avatars/avatar2.png\"),\n          \"/avatars/avatar3.png\": require(\"../../assets/avatars/avatar3.png\"),\n          \"/avatars/avatar4.png\": require(\"../../assets/avatars/avatar4.png\"),\n          \"/avatars/avatar5.png\": require(\"../../assets/avatars/avatar5.png\"),\n          \"/avatars/avatar6.png\": require(\"../../assets/avatars/avatar6.png\"),\n        };\n        return avatarMap[photo] || require(\"../../assets/avatars/avatar1.png\");\n      }\n      return { uri: new URL(photo.startsWith(\"/objects/\") ? photo : `/objects/${photo}`, getApiUrl()).toString() };\n    }\n    return require(\"../../assets/avatars/avatar1.png\");\n  }, []);\n\n  const openAdvancedFilters = useCallback(() => {\n    setTempFilters({ ...advancedFilters });\n    setShowAdvancedFilters(true);\n  }, [advancedFilters]);\n\n  const applyFilters = useCallback(() => {\n    setAdvancedFilters({ ...tempFilters });\n    setShowAdvancedFilters(false);\n  }, [tempFilters]);\n\n  const resetFilters = useCallback(() => {\n    setTempFilters({ ...defaultFilters });\n  }, []);\n\n  const renderUser = ({ item }: { item: User }) => (\n    <Pressable\n      style={({ pressed }) => [\n        styles.userCard,\n        { backgroundColor: theme.cardBackground, opacity: pressed ? 0.95 : 1 },\n      ]}\n      onPress={() => navigation.navigate(\"UserProfile\", { userId: item.id })}\n    >\n      <View style={styles.userCardContent}>\n        <View style={styles.avatarContainer}>\n          <Image source={getAvatarSource(item)} style={styles.avatar} />\n          {(isUserOnline(item.id) || item.isOnline) && <View style={[styles.onlineIndicator, { backgroundColor: theme.online }]} />}\n        </View>\n\n        <View style={styles.userInfo}>\n          <View style={styles.userNameRow}>\n            <ThemedText style={styles.userName}>\n              {item.name}{item.age ? `, ${item.age}` : \"\"}\n            </ThemedText>\n            <VerificationBadge\n              isVerified={item.isVerified || false}\n              verificationLevel={(item.verificationLevel as \"none\" | \"email\" | \"photo\" | \"id\") || \"none\"}\n              size=\"small\"\n            />\n          </View>\n          <ThemedText style={[styles.userLanguages, { color: theme.textSecondary }]}>\n            {item.nativeLanguage} {\"\\u2192\"} {(item.learningLanguages || []).join(\", \")}\n          </ThemedText>\n          {item.country ? (\n            <ThemedText style={[styles.userCountry, { color: theme.textSecondary }]}>\n              {item.country}\n            </ThemedText>\n          ) : null}\n        </View>\n\n        <Pressable\n          style={({ pressed }) => [\n            styles.chatButton,\n            { backgroundColor: theme.primary, opacity: pressed ? 0.8 : 1 },\n          ]}\n          onPress={(e) => {\n            e.stopPropagation();\n            navigation.navigate(\"Chat\", { user: item });\n          }}\n        >\n          <Feather name=\"message-circle\" size={18} color=\"#FFFFFF\" />\n        </Pressable>\n      </View>\n    </Pressable>\n  );\n\n  const renderSelectOption = (\n    value: string,\n    options: string[],\n    onChange: (val: string) => void,\n    placeholder: string\n  ) => (\n    <View style={styles.selectContainer}>\n      <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={styles.optionsRow}>\n        <Pressable\n          style={[\n            styles.optionChip,\n            { backgroundColor: value === \"\" ? theme.primary : theme.backgroundSecondary },\n          ]}\n          onPress={() => onChange(\"\")}\n        >\n          <ThemedText style={[styles.optionChipText, { color: value === \"\" ? \"#FFFFFF\" : theme.text }]}>\n            {placeholder}\n          </ThemedText>\n        </Pressable>\n        {options.map((opt) => (\n          <Pressable\n            key={opt}\n            style={[\n              styles.optionChip,\n              { backgroundColor: value === opt ? theme.primary : theme.backgroundSecondary },\n            ]}\n            onPress={() => onChange(opt)}\n          >\n            <ThemedText style={[styles.optionChipText, { color: value === opt ? \"#FFFFFF\" : theme.text }]}>\n              {opt}\n            </ThemedText>\n          </Pressable>\n        ))}\n      </ScrollView>\n    </View>\n  );\n\n  return (\n    <ThemedView style={styles.container}>\n      <View style={[styles.header, { paddingTop: insets.top + Spacing.lg }]}>\n        <ThemedText style={styles.headerTitle}>Community</ThemedText>\n        <Pressable\n          style={({ pressed }) => [\n            styles.filterButton,\n            { \n              backgroundColor: hasActiveFilters ? theme.primary : theme.backgroundSecondary, \n              opacity: pressed ? 0.8 : 1 \n            },\n          ]}\n          onPress={openAdvancedFilters}\n        >\n          <Feather name=\"sliders\" size={20} color={hasActiveFilters ? \"#FFFFFF\" : theme.text} />\n        </Pressable>\n      </View>\n\n      <View style={styles.filterBar}>\n        {([\"all\", \"new\", \"online\"] as const).map((f) => (\n          <Pressable\n            key={f}\n            style={({ pressed }) => [\n              styles.filterChip,\n              {\n                backgroundColor: filter === f ? theme.primary : theme.backgroundSecondary,\n                opacity: pressed ? 0.8 : 1,\n              },\n            ]}\n            onPress={() => setFilter(f)}\n          >\n            <ThemedText\n              style={[styles.filterChipText, { color: filter === f ? \"#FFFFFF\" : theme.text }]}\n            >\n              {f === \"all\" ? \"All Members\" : f === \"new\" ? \"New Members\" : \"Online\"}\n            </ThemedText>\n          </Pressable>\n        ))}\n      </View>\n\n      {isLoading ? (\n        <View style={styles.loadingContainer}>\n          <ActivityIndicator size=\"large\" color={theme.primary} />\n        </View>\n      ) : (\n        <FlatList\n          data={users}\n          renderItem={renderUser}\n          keyExtractor={(item) => item.id}\n          contentContainerStyle={[styles.list, { paddingBottom: tabBarHeight + Spacing.xl }]}\n          showsVerticalScrollIndicator={false}\n          refreshControl={\n            <RefreshControl refreshing={isRefetching} onRefresh={refetch} tintColor={theme.primary} />\n          }\n          ListEmptyComponent={\n            <View style={styles.emptyContainer}>\n              <Feather name=\"users\" size={48} color={theme.textSecondary} />\n              <ThemedText style={[styles.emptyText, { color: theme.textSecondary }]}>\n                No users found\n              </ThemedText>\n              {hasActiveFilters ? (\n                <Pressable\n                  style={[styles.clearFiltersButton, { borderColor: theme.primary }]}\n                  onPress={() => setAdvancedFilters(defaultFilters)}\n                >\n                  <ThemedText style={{ color: theme.primary }}>Clear Filters</ThemedText>\n                </Pressable>\n              ) : null}\n            </View>\n          }\n        />\n      )}\n\n      <Modal visible={showAdvancedFilters} animationType=\"slide\" transparent>\n        <View style={styles.modalOverlay}>\n          <View style={[styles.modalContent, { backgroundColor: theme.backgroundRoot }]}>\n            <View style={styles.modalHeader}>\n              <ThemedText style={styles.modalTitle}>Advanced Filters</ThemedText>\n              <Pressable onPress={() => setShowAdvancedFilters(false)}>\n                <Feather name=\"x\" size={24} color={theme.text} />\n              </Pressable>\n            </View>\n\n            <ScrollView style={styles.filtersScrollView} showsVerticalScrollIndicator={false}>\n              <View style={styles.filterSection}>\n                <ThemedText style={[styles.filterLabel, { color: theme.textSecondary }]}>\n                  Native Language\n                </ThemedText>\n                {renderSelectOption(\n                  tempFilters.nativeLanguage,\n                  LANGUAGES,\n                  (val) => setTempFilters({ ...tempFilters, nativeLanguage: val }),\n                  \"Any\"\n                )}\n              </View>\n\n              <View style={styles.filterSection}>\n                <ThemedText style={[styles.filterLabel, { color: theme.textSecondary }]}>\n                  Learning Language\n                </ThemedText>\n                {renderSelectOption(\n                  tempFilters.learningLanguage,\n                  LANGUAGES,\n                  (val) => setTempFilters({ ...tempFilters, learningLanguage: val }),\n                  \"Any\"\n                )}\n              </View>\n\n              <View style={styles.filterSection}>\n                <ThemedText style={[styles.filterLabel, { color: theme.textSecondary }]}>\n                  Country\n                </ThemedText>\n                {renderSelectOption(\n                  tempFilters.country,\n                  COUNTRIES,\n                  (val) => setTempFilters({ ...tempFilters, country: val }),\n                  \"Any\"\n                )}\n              </View>\n\n              <View style={styles.filterSection}>\n                <ThemedText style={[styles.filterLabel, { color: theme.textSecondary }]}>\n                  Hobbies\n                </ThemedText>\n                <TextInput\n                  style={[styles.textInput, { backgroundColor: theme.backgroundSecondary, color: theme.text }]}\n                  placeholder=\"Search by hobbies...\"\n                  placeholderTextColor={theme.textSecondary}\n                  value={tempFilters.hobbies}\n                  onChangeText={(val) => setTempFilters({ ...tempFilters, hobbies: val })}\n                />\n              </View>\n\n              <View style={styles.filterSection}>\n                <ThemedText style={[styles.filterLabel, { color: theme.textSecondary }]}>\n                  Topics\n                </ThemedText>\n                <TextInput\n                  style={[styles.textInput, { backgroundColor: theme.backgroundSecondary, color: theme.text }]}\n                  placeholder=\"Search by topics...\"\n                  placeholderTextColor={theme.textSecondary}\n                  value={tempFilters.topics}\n                  onChangeText={(val) => setTempFilters({ ...tempFilters, topics: val })}\n                />\n              </View>\n\n              <View style={styles.filterSection}>\n                <Pressable\n                  style={[\n                    styles.verifiedToggle,\n                    {\n                      backgroundColor: tempFilters.verifiedOnly ? theme.primary : theme.backgroundSecondary,\n                    },\n                  ]}\n                  onPress={() => setTempFilters({ ...tempFilters, verifiedOnly: !tempFilters.verifiedOnly })}\n                >\n                  <Feather\n                    name=\"shield\"\n                    size={18}\n                    color={tempFilters.verifiedOnly ? \"#FFFFFF\" : theme.text}\n                  />\n                  <ThemedText\n                    style={[\n                      styles.verifiedToggleText,\n                      { color: tempFilters.verifiedOnly ? \"#FFFFFF\" : theme.text },\n                    ]}\n                  >\n                    Verified Users Only\n                  </ThemedText>\n                </Pressable>\n              </View>\n\n              <View style={styles.filterSection}>\n                <ThemedText style={[styles.filterLabel, { color: theme.textSecondary }]}>\n                  Age Range: {tempFilters.minAge} - {tempFilters.maxAge}\n                </ThemedText>\n\n                <View style={styles.ageButtons}>\n                  <View style={styles.ageButtonGroup}>\n                    <ThemedText style={{ color: theme.textSecondary }}>Min:</ThemedText>\n                    <Pressable\n                      style={[styles.ageAdjustButton, { backgroundColor: theme.backgroundSecondary }]}\n                      onPress={() => setTempFilters({ ...tempFilters, minAge: Math.max(18, tempFilters.minAge - 1) })}\n                    >\n                      <Feather name=\"minus\" size={16} color={theme.text} />\n                    </Pressable>\n                    <ThemedText style={styles.ageValue}>{tempFilters.minAge}</ThemedText>\n                    <Pressable\n                      style={[styles.ageAdjustButton, { backgroundColor: theme.backgroundSecondary }]}\n                      onPress={() => setTempFilters({ ...tempFilters, minAge: Math.min(tempFilters.maxAge - 1, tempFilters.minAge + 1) })}\n                    >\n                      <Feather name=\"plus\" size={16} color={theme.text} />\n                    </Pressable>\n                  </View>\n\n                  <View style={styles.ageButtonGroup}>\n                    <ThemedText style={{ color: theme.textSecondary }}>Max:</ThemedText>\n                    <Pressable\n                      style={[styles.ageAdjustButton, { backgroundColor: theme.backgroundSecondary }]}\n                      onPress={() => setTempFilters({ ...tempFilters, maxAge: Math.max(tempFilters.minAge + 1, tempFilters.maxAge - 1) })}\n                    >\n                      <Feather name=\"minus\" size={16} color={theme.text} />\n                    </Pressable>\n                    <ThemedText style={styles.ageValue}>{tempFilters.maxAge}</ThemedText>\n                    <Pressable\n                      style={[styles.ageAdjustButton, { backgroundColor: theme.backgroundSecondary }]}\n                      onPress={() => setTempFilters({ ...tempFilters, maxAge: Math.min(65, tempFilters.maxAge + 1) })}\n                    >\n                      <Feather name=\"plus\" size={16} color={theme.text} />\n                    </Pressable>\n                  </View>\n                </View>\n              </View>\n            </ScrollView>\n\n            <View style={[styles.modalFooter, { paddingBottom: insets.bottom + Spacing.lg }]}>\n              <Pressable\n                style={[styles.resetButton, { borderColor: theme.border }]}\n                onPress={resetFilters}\n              >\n                <ThemedText>Reset</ThemedText>\n              </Pressable>\n              <Pressable\n                style={[styles.applyButton, { backgroundColor: theme.primary }]}\n                onPress={applyFilters}\n              >\n                <ThemedText style={{ color: \"#FFFFFF\", fontWeight: \"600\" }}>Apply</ThemedText>\n              </Pressable>\n            </View>\n          </View>\n        </View>\n      </Modal>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  header: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.lg,\n  },\n  headerTitle: {\n    ...Typography.h3,\n  },\n  filterButton: {\n    width: 40,\n    height: 40,\n    borderRadius: BorderRadius.xs,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  filterBar: {\n    flexDirection: \"row\",\n    paddingHorizontal: Spacing.xl,\n    paddingBottom: Spacing.lg,\n    gap: Spacing.sm,\n  },\n  filterChip: {\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.sm,\n    borderRadius: BorderRadius.full,\n  },\n  filterChipText: {\n    ...Typography.small,\n    fontWeight: \"500\",\n  },\n  loadingContainer: {\n    flex: 1,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  list: {\n    paddingHorizontal: Spacing.xl,\n    gap: Spacing.md,\n  },\n  userCard: {\n    borderRadius: BorderRadius.sm,\n    padding: Spacing.lg,\n  },\n  userCardContent: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n  },\n  avatarContainer: {\n    position: \"relative\",\n  },\n  avatar: {\n    width: 60,\n    height: 60,\n    borderRadius: 30,\n  },\n  onlineIndicator: {\n    position: \"absolute\",\n    bottom: 2,\n    right: 2,\n    width: 14,\n    height: 14,\n    borderRadius: 7,\n    borderWidth: 2,\n    borderColor: \"#FFFFFF\",\n  },\n  userInfo: {\n    flex: 1,\n    marginLeft: Spacing.lg,\n  },\n  userNameRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n    marginBottom: Spacing.xs,\n  },\n  userName: {\n    ...Typography.body,\n    fontWeight: \"600\",\n  },\n  userLanguages: {\n    ...Typography.small,\n  },\n  userCountry: {\n    ...Typography.small,\n    marginTop: 2,\n  },\n  chatButton: {\n    width: 40,\n    height: 40,\n    borderRadius: 20,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  emptyContainer: {\n    alignItems: \"center\",\n    paddingTop: Spacing[\"5xl\"],\n  },\n  emptyText: {\n    marginTop: Spacing.lg,\n    ...Typography.body,\n  },\n  clearFiltersButton: {\n    marginTop: Spacing.lg,\n    paddingHorizontal: Spacing.xl,\n    paddingVertical: Spacing.sm,\n    borderRadius: BorderRadius.sm,\n    borderWidth: 1,\n  },\n  modalOverlay: {\n    flex: 1,\n    backgroundColor: \"rgba(0,0,0,0.5)\",\n    justifyContent: \"flex-end\",\n  },\n  modalContent: {\n    borderTopLeftRadius: BorderRadius.lg,\n    borderTopRightRadius: BorderRadius.lg,\n    maxHeight: \"85%\",\n  },\n  modalHeader: {\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\",\n    padding: Spacing.xl,\n    paddingBottom: Spacing.lg,\n  },\n  modalTitle: {\n    ...Typography.h4,\n  },\n  filtersScrollView: {\n    paddingHorizontal: Spacing.xl,\n  },\n  filterSection: {\n    marginBottom: Spacing.xl,\n  },\n  filterLabel: {\n    ...Typography.small,\n    fontWeight: \"600\",\n    marginBottom: Spacing.sm,\n  },\n  selectContainer: {\n    marginTop: Spacing.xs,\n  },\n  optionsRow: {\n    flexDirection: \"row\",\n    gap: Spacing.sm,\n    paddingRight: Spacing.xl,\n  },\n  optionChip: {\n    paddingHorizontal: Spacing.md,\n    paddingVertical: Spacing.sm,\n    borderRadius: BorderRadius.full,\n  },\n  optionChipText: {\n    ...Typography.small,\n  },\n  textInput: {\n    height: 44,\n    borderRadius: BorderRadius.sm,\n    paddingHorizontal: Spacing.lg,\n    ...Typography.body,\n  },\n  ageButtons: {\n    flexDirection: \"row\",\n    justifyContent: \"space-around\",\n    marginTop: Spacing.md,\n  },\n  ageButtonGroup: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n  },\n  ageAdjustButton: {\n    width: 32,\n    height: 32,\n    borderRadius: 16,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  ageValue: {\n    ...Typography.body,\n    fontWeight: \"600\",\n    minWidth: 30,\n    textAlign: \"center\",\n  },\n  modalFooter: {\n    flexDirection: \"row\",\n    gap: Spacing.md,\n    padding: Spacing.xl,\n    paddingTop: Spacing.lg,\n  },\n  resetButton: {\n    flex: 1,\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.sm,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    borderWidth: 1,\n  },\n  applyButton: {\n    flex: 1,\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.sm,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  verifiedToggle: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    paddingVertical: Spacing.md,\n    paddingHorizontal: Spacing.lg,\n    borderRadius: BorderRadius.sm,\n    gap: Spacing.sm,\n  },\n  verifiedToggleText: {\n    ...Typography.body,\n    fontWeight: \"500\",\n  },\n});\n","path":null,"size_bytes":24030,"size_tokens":null},"server/routes.ts":{"content":"import type { Express } from \"express\";\nimport { createServer, type Server } from \"node:http\";\nimport { storage } from \"./storage\";\nimport { compare, generateToken, authMiddleware, type AuthenticatedRequest } from \"./auth\";\nimport { registerSchema, loginSchema, updateProfileSchema } from \"@shared/schema\";\nimport { ObjectStorageService, ObjectNotFoundError } from \"./objectStorage\";\nimport { initializeWebSocket } from \"./websocket\";\nimport { sendNewMessageNotification } from \"./pushNotifications\";\n\nexport async function registerRoutes(app: Express): Promise<Server> {\n  await storage.seedBotUsers();\n\n  app.post(\"/api/auth/register\", async (req, res) => {\n    try {\n      const result = registerSchema.safeParse(req.body);\n      if (!result.success) {\n        return res.status(400).json({ error: result.error.errors[0].message });\n      }\n\n      const { email, password, name } = result.data;\n\n      const existingUser = await storage.getUserByEmail(email);\n      if (existingUser) {\n        return res.status(400).json({ error: \"Email already registered\" });\n      }\n\n      const user = await storage.createUser({ email, password, name });\n      const token = generateToken(user.id);\n\n      res.json({\n        user: { ...user, password: undefined },\n        token,\n      });\n    } catch (error) {\n      console.error(\"Register error:\", error);\n      res.status(500).json({ error: \"Failed to register\" });\n    }\n  });\n\n  app.post(\"/api/auth/login\", async (req, res) => {\n    try {\n      const result = loginSchema.safeParse(req.body);\n      if (!result.success) {\n        return res.status(400).json({ error: result.error.errors[0].message });\n      }\n\n      const { email, password } = result.data;\n\n      const user = await storage.getUserByEmail(email);\n      if (!user) {\n        return res.status(401).json({ error: \"Invalid email or password\" });\n      }\n\n      const isValidPassword = await compare(password, user.password);\n      if (!isValidPassword) {\n        return res.status(401).json({ error: \"Invalid email or password\" });\n      }\n\n      await storage.updateUser(user.id, { isOnline: true, lastSeen: new Date() });\n\n      const token = generateToken(user.id);\n\n      res.json({\n        user: { ...user, password: undefined },\n        token,\n      });\n    } catch (error) {\n      console.error(\"Login error:\", error);\n      res.status(500).json({ error: \"Failed to login\" });\n    }\n  });\n\n  app.get(\"/api/auth/me\", authMiddleware, async (req: AuthenticatedRequest, res) => {\n    try {\n      const user = await storage.getUser(req.userId!);\n      if (!user) {\n        return res.status(404).json({ error: \"User not found\" });\n      }\n      res.json({ ...user, password: undefined });\n    } catch (error) {\n      console.error(\"Get me error:\", error);\n      res.status(500).json({ error: \"Failed to get user\" });\n    }\n  });\n\n  app.post(\"/api/auth/logout\", authMiddleware, async (req: AuthenticatedRequest, res) => {\n    try {\n      await storage.updateUser(req.userId!, { isOnline: false, lastSeen: new Date() });\n      res.json({ success: true });\n    } catch (error) {\n      console.error(\"Logout error:\", error);\n      res.status(500).json({ error: \"Failed to logout\" });\n    }\n  });\n\n  app.put(\"/api/users/profile\", authMiddleware, async (req: AuthenticatedRequest, res) => {\n    try {\n      const result = updateProfileSchema.safeParse(req.body);\n      if (!result.success) {\n        return res.status(400).json({ error: result.error.errors[0].message });\n      }\n\n      const user = await storage.updateUser(req.userId!, result.data);\n      if (!user) {\n        return res.status(404).json({ error: \"User not found\" });\n      }\n\n      res.json({ ...user, password: undefined });\n    } catch (error) {\n      console.error(\"Update profile error:\", error);\n      res.status(500).json({ error: \"Failed to update profile\" });\n    }\n  });\n\n  app.get(\"/api/users\", authMiddleware, async (req: AuthenticatedRequest, res) => {\n    try {\n      const { online, newMembers, minAge, maxAge, nativeLanguage, learningLanguage, country, hobbies, topics, verifiedOnly } = req.query;\n      \n      const filters: any = { excludeId: req.userId };\n      \n      if (online === \"true\") {\n        filters.isOnline = true;\n      }\n      \n      if (newMembers === \"true\") {\n        filters.isNew = true;\n      }\n      \n      if (minAge) {\n        filters.minAge = parseInt(minAge as string);\n      }\n      \n      if (maxAge) {\n        filters.maxAge = parseInt(maxAge as string);\n      }\n      \n      if (nativeLanguage) {\n        filters.nativeLanguage = nativeLanguage as string;\n      }\n      \n      if (learningLanguage) {\n        filters.learningLanguage = learningLanguage as string;\n      }\n      \n      if (country) {\n        filters.country = country as string;\n      }\n      \n      if (hobbies) {\n        filters.hobbies = hobbies as string;\n      }\n      \n      if (topics) {\n        filters.topics = topics as string;\n      }\n      \n      if (verifiedOnly === \"true\") {\n        filters.verifiedOnly = true;\n      }\n\n      const users = await storage.getUsers(filters);\n      res.json(users.map(u => ({ ...u, password: undefined })));\n    } catch (error) {\n      console.error(\"Get users error:\", error);\n      res.status(500).json({ error: \"Failed to get users\" });\n    }\n  });\n\n  app.get(\"/api/users/:id\", authMiddleware, async (req: AuthenticatedRequest, res) => {\n    try {\n      const user = await storage.getUser(req.params.id);\n      if (!user) {\n        return res.status(404).json({ error: \"User not found\" });\n      }\n      res.json({ ...user, password: undefined });\n    } catch (error) {\n      console.error(\"Get user error:\", error);\n      res.status(500).json({ error: \"Failed to get user\" });\n    }\n  });\n\n  app.get(\"/api/conversations\", authMiddleware, async (req: AuthenticatedRequest, res) => {\n    try {\n      const conversations = await storage.getConversations(req.userId!);\n      res.json(conversations.map(c => ({\n        user: { ...c.user, password: undefined },\n        lastMessage: c.lastMessage,\n      })));\n    } catch (error) {\n      console.error(\"Get conversations error:\", error);\n      res.status(500).json({ error: \"Failed to get conversations\" });\n    }\n  });\n\n  app.get(\"/api/messages/:userId\", authMiddleware, async (req: AuthenticatedRequest, res) => {\n    try {\n      const messages = await storage.getMessages(req.userId!, req.params.userId);\n      res.json(messages);\n    } catch (error) {\n      console.error(\"Get messages error:\", error);\n      res.status(500).json({ error: \"Failed to get messages\" });\n    }\n  });\n\n  app.post(\"/api/messages\", authMiddleware, async (req: AuthenticatedRequest, res) => {\n    try {\n      const { receiverId, content } = req.body;\n      \n      if (!receiverId || !content) {\n        return res.status(400).json({ error: \"Receiver ID and content are required\" });\n      }\n\n      const isBlocked = await storage.isBlocked(req.userId!, receiverId);\n      if (isBlocked) {\n        return res.status(403).json({ error: \"Cannot send message to this user\" });\n      }\n\n      const message = await storage.createMessage(req.userId!, receiverId, content);\n      \n      sendNewMessageNotification(req.userId!, receiverId, content).catch((err) => {\n        console.error(\"Failed to send push notification:\", err);\n      });\n      \n      res.json(message);\n    } catch (error) {\n      console.error(\"Send message error:\", error);\n      res.status(500).json({ error: \"Failed to send message\" });\n    }\n  });\n\n  app.post(\"/api/push-token\", authMiddleware, async (req: AuthenticatedRequest, res) => {\n    try {\n      const { pushToken } = req.body;\n      \n      if (!pushToken || typeof pushToken !== \"string\") {\n        return res.status(400).json({ error: \"Push token is required\" });\n      }\n\n      if (!pushToken.startsWith(\"ExponentPushToken[\")) {\n        return res.status(400).json({ error: \"Invalid push token format\" });\n      }\n\n      await storage.updateUser(req.userId!, { pushToken });\n      res.json({ success: true });\n    } catch (error) {\n      console.error(\"Save push token error:\", error);\n      res.status(500).json({ error: \"Failed to save push token\" });\n    }\n  });\n\n  app.delete(\"/api/push-token\", authMiddleware, async (req: AuthenticatedRequest, res) => {\n    try {\n      await storage.updateUser(req.userId!, { pushToken: null as any });\n      res.json({ success: true });\n    } catch (error) {\n      console.error(\"Delete push token error:\", error);\n      res.status(500).json({ error: \"Failed to delete push token\" });\n    }\n  });\n\n  app.post(\"/api/messages/:messageId/report\", authMiddleware, async (req: AuthenticatedRequest, res) => {\n    try {\n      const { reason } = req.body;\n      const report = await storage.reportMessage(req.params.messageId, req.userId!, reason);\n      res.json(report);\n    } catch (error) {\n      console.error(\"Report message error:\", error);\n      res.status(500).json({ error: \"Failed to report message\" });\n    }\n  });\n\n  app.post(\"/api/users/:userId/block\", authMiddleware, async (req: AuthenticatedRequest, res) => {\n    try {\n      const blocked = await storage.blockUser(req.userId!, req.params.userId);\n      res.json(blocked);\n    } catch (error) {\n      console.error(\"Block user error:\", error);\n      res.status(500).json({ error: \"Failed to block user\" });\n    }\n  });\n\n  app.delete(\"/api/users/:userId/block\", authMiddleware, async (req: AuthenticatedRequest, res) => {\n    try {\n      await storage.unblockUser(req.userId!, req.params.userId);\n      res.json({ success: true });\n    } catch (error) {\n      console.error(\"Unblock user error:\", error);\n      res.status(500).json({ error: \"Failed to unblock user\" });\n    }\n  });\n\n  app.post(\"/api/users/:userId/report\", authMiddleware, async (req: AuthenticatedRequest, res) => {\n    try {\n      const { reason } = req.body;\n      const report = await storage.reportUser(req.userId!, req.params.userId, reason);\n      res.json(report);\n    } catch (error) {\n      console.error(\"Report user error:\", error);\n      res.status(500).json({ error: \"Failed to report user\" });\n    }\n  });\n\n  app.get(\"/public-objects/:filePath(*)\", async (req, res) => {\n    const filePath = req.params.filePath;\n    const objectStorageService = new ObjectStorageService();\n    try {\n      const file = await objectStorageService.searchPublicObject(filePath);\n      if (!file) {\n        return res.status(404).json({ error: \"File not found\" });\n      }\n      objectStorageService.downloadObject(file, res);\n    } catch (error) {\n      console.error(\"Error searching for public object:\", error);\n      return res.status(500).json({ error: \"Internal server error\" });\n    }\n  });\n\n  app.get(\"/objects/:objectPath(*)\", authMiddleware, async (req: AuthenticatedRequest, res) => {\n    const objectStorageService = new ObjectStorageService();\n    try {\n      const objectFile = await objectStorageService.getObjectEntityFile(req.path);\n      objectStorageService.downloadObject(objectFile, res);\n    } catch (error) {\n      console.error(\"Error checking object access:\", error);\n      if (error instanceof ObjectNotFoundError) {\n        return res.sendStatus(404);\n      }\n      return res.sendStatus(500);\n    }\n  });\n\n  app.post(\"/api/objects/upload\", authMiddleware, async (req: AuthenticatedRequest, res) => {\n    const objectStorageService = new ObjectStorageService();\n    try {\n      const uploadURL = await objectStorageService.getObjectEntityUploadURL();\n      res.json({ uploadURL });\n    } catch (error) {\n      console.error(\"Error getting upload URL:\", error);\n      res.status(500).json({ error: \"Failed to get upload URL\" });\n    }\n  });\n\n  app.put(\"/api/profile-photos\", authMiddleware, async (req: AuthenticatedRequest, res) => {\n    if (!req.body.photoURL) {\n      return res.status(400).json({ error: \"photoURL is required\" });\n    }\n\n    try {\n      const objectStorageService = new ObjectStorageService();\n      const objectPath = objectStorageService.normalizeObjectEntityPath(req.body.photoURL);\n\n      const user = await storage.getUser(req.userId!);\n      if (!user) {\n        return res.status(404).json({ error: \"User not found\" });\n      }\n\n      const photos = user.photos || [];\n      if (photos.length >= 4) {\n        return res.status(400).json({ error: \"Maximum 4 photos allowed\" });\n      }\n\n      photos.push(objectPath);\n      await storage.updateUser(req.userId!, { photos });\n\n      res.status(200).json({ objectPath, photos });\n    } catch (error) {\n      console.error(\"Error setting profile photo:\", error);\n      res.status(500).json({ error: \"Internal server error\" });\n    }\n  });\n\n  app.delete(\"/api/profile-photos/:index\", authMiddleware, async (req: AuthenticatedRequest, res) => {\n    try {\n      const index = parseInt(req.params.index);\n      const user = await storage.getUser(req.userId!);\n      \n      if (!user) {\n        return res.status(404).json({ error: \"User not found\" });\n      }\n\n      const photos = user.photos || [];\n      if (index < 0 || index >= photos.length) {\n        return res.status(400).json({ error: \"Invalid photo index\" });\n      }\n\n      photos.splice(index, 1);\n      \n      let avatarIndex = user.avatarIndex || 0;\n      if (avatarIndex >= photos.length) {\n        avatarIndex = Math.max(0, photos.length - 1);\n      }\n\n      await storage.updateUser(req.userId!, { photos, avatarIndex });\n\n      res.json({ photos, avatarIndex });\n    } catch (error) {\n      console.error(\"Error deleting photo:\", error);\n      res.status(500).json({ error: \"Internal server error\" });\n    }\n  });\n\n  app.post(\"/api/translate\", authMiddleware, async (req: AuthenticatedRequest, res) => {\n    try {\n      const { text, targetLanguage } = req.body;\n      \n      if (!text || !targetLanguage) {\n        return res.status(400).json({ error: \"Text and target language are required\" });\n      }\n\n      const response = await fetch(\n        `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=autodetect|${targetLanguage}`\n      );\n      \n      const data = await response.json();\n      \n      if (data.responseStatus === 200) {\n        res.json({ translatedText: data.responseData.translatedText });\n      } else {\n        res.status(400).json({ error: \"Translation failed\" });\n      }\n    } catch (error) {\n      console.error(\"Translation error:\", error);\n      res.status(500).json({ error: \"Failed to translate\" });\n    }\n  });\n\n  const httpServer = createServer(app);\n\n  initializeWebSocket(httpServer);\n\n  return httpServer;\n}\n","path":null,"size_bytes":14491,"size_tokens":null},"client/contexts/NotificationContext.tsx":{"content":"import React, { createContext, useContext, useState, useEffect, useRef, useCallback, type ReactNode } from 'react';\nimport { Platform } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport * as Device from 'expo-device';\nimport Constants from 'expo-constants';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport { useAuth } from './AuthContext';\nimport { getApiUrl } from '@/lib/query-client';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: true,\n    shouldSetBadge: false,\n    shouldShowBanner: true,\n    shouldShowList: true,\n  }),\n});\n\ninterface NotificationContextType {\n  expoPushToken: string | null;\n  notification: Notifications.Notification | null;\n  notificationsEnabled: boolean;\n  requestPermissions: () => Promise<boolean>;\n  disableNotifications: () => Promise<void>;\n}\n\nconst NotificationContext = createContext<NotificationContextType | undefined>(undefined);\n\nconst NOTIFICATIONS_ENABLED_KEY = '@lanchat_notifications_enabled';\n\nexport function NotificationProvider({ children }: { children: ReactNode }) {\n  const { token, isAuthenticated } = useAuth();\n  const [expoPushToken, setExpoPushToken] = useState<string | null>(null);\n  const [notification, setNotification] = useState<Notifications.Notification | null>(null);\n  const [notificationsEnabled, setNotificationsEnabled] = useState(false);\n  const notificationListener = useRef<Notifications.EventSubscription | null>(null);\n  const responseListener = useRef<Notifications.EventSubscription | null>(null);\n  const tokenRef = useRef<string | null>(token);\n\n  useEffect(() => {\n    tokenRef.current = token;\n  }, [token]);\n\n  useEffect(() => {\n    loadNotificationPreference();\n\n    notificationListener.current = Notifications.addNotificationReceivedListener(notification => {\n      setNotification(notification);\n    });\n\n    responseListener.current = Notifications.addNotificationResponseReceivedListener(response => {\n      const data = response.notification.request.content.data;\n      if (data?.type === 'new_message' && data?.senderId) {\n        // Navigation can be handled by the app\n      }\n    });\n\n    return () => {\n      if (notificationListener.current) {\n        notificationListener.current.remove();\n      }\n      if (responseListener.current) {\n        responseListener.current.remove();\n      }\n    };\n  }, []);\n\n  const loadNotificationPreference = async () => {\n    try {\n      const enabled = await AsyncStorage.getItem(NOTIFICATIONS_ENABLED_KEY);\n      if (enabled === 'true') {\n        setNotificationsEnabled(true);\n      }\n    } catch (error) {\n      console.error('Failed to load notification preference:', error);\n    }\n  };\n\n  const savePushTokenToServer = useCallback(async (pushToken: string) => {\n    const authToken = tokenRef.current;\n    if (!authToken) return;\n    \n    try {\n      const response = await fetch(new URL('/api/push-token', getApiUrl()).toString(), {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          Authorization: `Bearer ${authToken}`,\n        },\n        body: JSON.stringify({ pushToken }),\n      });\n\n      if (!response.ok) {\n        console.error('Failed to save push token to server');\n      }\n    } catch (error) {\n      console.error('Error saving push token:', error);\n    }\n  }, []);\n\n  const deletePushTokenFromServer = useCallback(async () => {\n    const authToken = tokenRef.current;\n    if (!authToken) return;\n    \n    try {\n      await fetch(new URL('/api/push-token', getApiUrl()).toString(), {\n        method: 'DELETE',\n        headers: {\n          Authorization: `Bearer ${authToken}`,\n        },\n      });\n    } catch (error) {\n      console.error('Error deleting push token:', error);\n    }\n  }, []);\n\n  const registerForPushNotifications = useCallback(async () => {\n    if (Platform.OS === 'web') {\n      return;\n    }\n\n    if (!Device.isDevice) {\n      console.log('Push notifications only work on physical devices');\n      return;\n    }\n\n    try {\n      const { status: existingStatus } = await Notifications.getPermissionsAsync();\n      let finalStatus = existingStatus;\n\n      if (existingStatus !== 'granted') {\n        const { status } = await Notifications.requestPermissionsAsync();\n        finalStatus = status;\n      }\n\n      if (finalStatus !== 'granted') {\n        console.log('Push notification permission not granted');\n        return;\n      }\n\n      const projectId = Constants.expoConfig?.extra?.eas?.projectId ?? Constants.easConfig?.projectId;\n      \n      const tokenData = await Notifications.getExpoPushTokenAsync({\n        projectId,\n      });\n\n      const pushToken = tokenData.data;\n      setExpoPushToken(pushToken);\n\n      if (tokenRef.current && pushToken) {\n        await savePushTokenToServer(pushToken);\n      }\n\n      if (Platform.OS === 'android') {\n        await Notifications.setNotificationChannelAsync('default', {\n          name: 'default',\n          importance: Notifications.AndroidImportance.MAX,\n          vibrationPattern: [0, 250, 250, 250],\n          lightColor: '#6366f1',\n        });\n      }\n    } catch (error) {\n      console.error('Failed to register for push notifications:', error);\n    }\n  }, [savePushTokenToServer]);\n\n  useEffect(() => {\n    if (isAuthenticated && notificationsEnabled) {\n      registerForPushNotifications();\n    }\n  }, [isAuthenticated, notificationsEnabled, registerForPushNotifications]);\n\n  const requestPermissions = useCallback(async (): Promise<boolean> => {\n    if (Platform.OS === 'web') {\n      return false;\n    }\n\n    if (!Device.isDevice) {\n      return false;\n    }\n\n    try {\n      const { status } = await Notifications.requestPermissionsAsync();\n      \n      if (status === 'granted') {\n        setNotificationsEnabled(true);\n        await AsyncStorage.setItem(NOTIFICATIONS_ENABLED_KEY, 'true');\n        await registerForPushNotifications();\n        return true;\n      }\n      \n      return false;\n    } catch (error) {\n      console.error('Failed to request notification permissions:', error);\n      return false;\n    }\n  }, [registerForPushNotifications]);\n\n  const disableNotifications = useCallback(async () => {\n    setNotificationsEnabled(false);\n    setExpoPushToken(null);\n    await AsyncStorage.setItem(NOTIFICATIONS_ENABLED_KEY, 'false');\n    await deletePushTokenFromServer();\n  }, [deletePushTokenFromServer]);\n\n  return (\n    <NotificationContext.Provider\n      value={{\n        expoPushToken,\n        notification,\n        notificationsEnabled,\n        requestPermissions,\n        disableNotifications,\n      }}\n    >\n      {children}\n    </NotificationContext.Provider>\n  );\n}\n\nexport function useNotifications() {\n  const context = useContext(NotificationContext);\n  if (context === undefined) {\n    throw new Error('useNotifications must be used within a NotificationProvider');\n  }\n  return context;\n}\n","path":null,"size_bytes":6940,"size_tokens":null},"client/utils/objectStorageExpo.ts":{"content":"import { File } from 'expo-file-system';\nimport { fetch } from 'expo/fetch';\nimport { getApiUrl } from '@/lib/query-client';\n\nexport async function uploadFileToStorage(\n  file: File,\n  getUploadUrlEndpoint: string = '/api/objects/upload',\n  token?: string,\n): Promise<string> {\n  const apiUrl = getApiUrl();\n  const uploadUrlEndpoint = new URL(getUploadUrlEndpoint, apiUrl).toString();\n  \n  const headers: Record<string, string> = {};\n  if (token) {\n    headers['Authorization'] = `Bearer ${token}`;\n  }\n  \n  const presignedUrlResponse = await fetch(uploadUrlEndpoint, {\n    method: 'POST',\n    headers,\n    credentials: 'include',\n  });\n\n  if (!presignedUrlResponse.ok) {\n    throw new Error(\n      `Failed to get presigned URL with status: ${presignedUrlResponse.status}`\n    );\n  }\n\n  const { uploadURL } = await presignedUrlResponse.json();\n  if (!uploadURL) {\n    throw new Error('No uploadURL returned from server');\n  }\n  \n  const uploadResponse = await fetch(uploadURL.toString(), {\n    method: 'PUT',\n    body: file,\n    headers: {\n      'Content-Type': file.type || 'application/octet-stream',\n    },\n  });\n\n  if (!uploadResponse.ok) {\n    throw new Error(\n      `Upload to object storage failed with status: ${uploadResponse.status}`\n    );\n  }\n\n  return uploadURL;\n}\n","path":null,"size_bytes":1279,"size_tokens":null},"client/screens/UserProfileScreen.tsx":{"content":"import React, { useCallback, useState } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  ScrollView,\n  Pressable,\n  Image,\n  Dimensions,\n  Alert,\n  ActivityIndicator,\n} from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useNavigation, useRoute, type RouteProp } from \"@react-navigation/native\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { VerificationBadge, SafetyIndicator } from \"@/components/VerificationBadge\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useAuth } from \"@/contexts/AuthContext\";\nimport { Spacing, BorderRadius, Typography } from \"@/constants/theme\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { getApiUrl } from \"@/lib/query-client\";\nimport type { User } from \"@shared/schema\";\nimport type { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport type { RootStackParamList } from \"@/navigation/RootStackNavigator\";\n\ntype NavigationProp = NativeStackNavigationProp<RootStackParamList>;\ntype ProfileRouteProp = RouteProp<RootStackParamList, \"UserProfile\">;\n\nconst { width: SCREEN_WIDTH } = Dimensions.get(\"window\");\n\nexport default function UserProfileScreen() {\n  const insets = useSafeAreaInsets();\n  const { theme } = useTheme();\n  const { token } = useAuth();\n  const navigation = useNavigation<NavigationProp>();\n  const route = useRoute<ProfileRouteProp>();\n  const queryClient = useQueryClient();\n\n  const [currentPhotoIndex, setCurrentPhotoIndex] = useState(0);\n\n  const { data: user, isLoading } = useQuery<User>({\n    queryKey: [\"/api/users\", route.params.userId],\n    queryFn: async () => {\n      const response = await fetch(\n        new URL(`/api/users/${route.params.userId}`, getApiUrl()).toString(),\n        { headers: { Authorization: `Bearer ${token}` } }\n      );\n      if (!response.ok) throw new Error(\"Failed to fetch user\");\n      return response.json();\n    },\n  });\n\n  const blockMutation = useMutation({\n    mutationFn: async () => {\n      const response = await fetch(\n        new URL(`/api/users/${route.params.userId}/block`, getApiUrl()).toString(),\n        { method: \"POST\", headers: { Authorization: `Bearer ${token}` } }\n      );\n      if (!response.ok) throw new Error(\"Failed to block user\");\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: [\"/api/users\"] });\n      navigation.goBack();\n    },\n  });\n\n  const reportMutation = useMutation({\n    mutationFn: async (reason: string) => {\n      const response = await fetch(\n        new URL(`/api/users/${route.params.userId}/report`, getApiUrl()).toString(),\n        {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            Authorization: `Bearer ${token}`,\n          },\n          body: JSON.stringify({ reason, type: \"profile\" }),\n        }\n      );\n      if (!response.ok) throw new Error(\"Failed to report user\");\n    },\n    onSuccess: () => {\n      Alert.alert(\"Report Submitted\", \"Thank you for helping keep our community safe.\");\n    },\n  });\n\n  const getPhotoSource = useCallback((photo: string) => {\n    if (photo.startsWith(\"/avatars/\")) {\n      const avatarMap: Record<string, any> = {\n        \"/avatars/avatar1.png\": require(\"../../assets/avatars/avatar1.png\"),\n        \"/avatars/avatar2.png\": require(\"../../assets/avatars/avatar2.png\"),\n        \"/avatars/avatar3.png\": require(\"../../assets/avatars/avatar3.png\"),\n        \"/avatars/avatar4.png\": require(\"../../assets/avatars/avatar4.png\"),\n        \"/avatars/avatar5.png\": require(\"../../assets/avatars/avatar5.png\"),\n        \"/avatars/avatar6.png\": require(\"../../assets/avatars/avatar6.png\"),\n      };\n      return avatarMap[photo] || require(\"../../assets/avatars/avatar1.png\");\n    }\n    return { uri: new URL(photo.startsWith(\"/objects/\") ? photo : `/objects/${photo}`, getApiUrl()).toString() };\n  }, []);\n\n  const handleBlock = () => {\n    Alert.alert(\n      \"Block User\",\n      `Are you sure you want to block ${user?.name}? You won't see each other anymore.`,\n      [\n        { text: \"Cancel\", style: \"cancel\" },\n        { text: \"Block\", style: \"destructive\", onPress: () => blockMutation.mutate() },\n      ]\n    );\n  };\n\n  const handleReport = () => {\n    Alert.alert(\n      \"Report User\",\n      \"Why are you reporting this profile?\",\n      [\n        { text: \"Cancel\", style: \"cancel\" },\n        { text: \"Inappropriate Content\", onPress: () => reportMutation.mutate(\"Inappropriate content\") },\n        { text: \"Spam\", onPress: () => reportMutation.mutate(\"Spam\") },\n        { text: \"Other\", onPress: () => reportMutation.mutate(\"Other\") },\n      ]\n    );\n  };\n\n  const handleStartChat = () => {\n    if (user) {\n      navigation.navigate(\"Chat\", { user });\n    }\n  };\n\n  if (isLoading) {\n    return (\n      <ThemedView style={[styles.container, styles.loadingContainer]}>\n        <ActivityIndicator size=\"large\" color={theme.primary} />\n      </ThemedView>\n    );\n  }\n\n  if (!user) {\n    return (\n      <ThemedView style={[styles.container, styles.loadingContainer]}>\n        <ThemedText>User not found</ThemedText>\n      </ThemedView>\n    );\n  }\n\n  const photos = user.photos?.length ? user.photos : [\"/avatars/avatar1.png\"];\n\n  return (\n    <ThemedView style={styles.container}>\n      <ScrollView\n        contentContainerStyle={{ paddingBottom: insets.bottom + Spacing.xl }}\n        showsVerticalScrollIndicator={false}\n      >\n        <ScrollView\n          horizontal\n          pagingEnabled\n          showsHorizontalScrollIndicator={false}\n          onMomentumScrollEnd={(e) => {\n            const index = Math.round(e.nativeEvent.contentOffset.x / SCREEN_WIDTH);\n            setCurrentPhotoIndex(index);\n          }}\n        >\n          {photos.map((photo, index) => (\n            <Image\n              key={index}\n              source={getPhotoSource(photo)}\n              style={styles.photo}\n              resizeMode=\"cover\"\n            />\n          ))}\n        </ScrollView>\n\n        {photos.length > 1 && (\n          <View style={styles.pagination}>\n            {photos.map((_, index) => (\n              <View\n                key={index}\n                style={[\n                  styles.paginationDot,\n                  {\n                    backgroundColor: index === currentPhotoIndex ? theme.primary : theme.border,\n                  },\n                ]}\n              />\n            ))}\n          </View>\n        )}\n\n        <View style={styles.profileInfo}>\n          <View style={styles.nameRow}>\n            <ThemedText style={styles.userName}>\n              {user.name}{user.age ? `, ${user.age}` : \"\"}\n            </ThemedText>\n            {user.isVerified && user.verificationLevel && user.verificationLevel !== \"none\" ? (\n              <VerificationBadge\n                isVerified={true}\n                verificationLevel={(user.verificationLevel as \"none\" | \"email\" | \"photo\" | \"id\")}\n                size=\"medium\"\n              />\n            ) : null}\n          </View>\n\n          {user.isVerified && user.verificationLevel && user.verificationLevel !== \"none\" ? (\n            <View style={styles.verificationLabelContainer}>\n              <VerificationBadge\n                isVerified={true}\n                verificationLevel={(user.verificationLevel as \"none\" | \"email\" | \"photo\" | \"id\")}\n                size=\"medium\"\n                showLabel\n              />\n            </View>\n          ) : null}\n\n          {user.nativeLanguage && (\n            <View style={styles.languageRow}>\n              <Feather name=\"globe\" size={16} color={theme.primary} />\n              <ThemedText style={[styles.languages, { color: theme.textSecondary }]}>\n                {user.nativeLanguage} {\"\\u2192\"} {(user.learningLanguages || []).join(\", \")}\n              </ThemedText>\n            </View>\n          )}\n\n          {user.hobbies && (\n            <View style={[styles.section, { backgroundColor: theme.cardBackground }]}>\n              <ThemedText style={[styles.sectionTitle, { color: theme.textSecondary }]}>\n                Hobbies\n              </ThemedText>\n              <ThemedText style={styles.sectionContent}>{user.hobbies}</ThemedText>\n            </View>\n          )}\n\n          {user.topics && (\n            <View style={[styles.section, { backgroundColor: theme.cardBackground }]}>\n              <ThemedText style={[styles.sectionTitle, { color: theme.textSecondary }]}>\n                Topics of Interest\n              </ThemedText>\n              <ThemedText style={styles.sectionContent}>{user.topics}</ThemedText>\n            </View>\n          )}\n\n          <SafetyIndicator />\n        </View>\n      </ScrollView>\n\n      <View style={[styles.actionBar, { paddingBottom: insets.bottom + Spacing.lg, backgroundColor: theme.backgroundRoot }]}>\n        <Pressable\n          style={({ pressed }) => [\n            styles.startChatButton,\n            { backgroundColor: theme.primary, opacity: pressed ? 0.9 : 1 },\n          ]}\n          onPress={handleStartChat}\n        >\n          <Feather name=\"message-circle\" size={20} color=\"#FFFFFF\" />\n          <ThemedText style={styles.startChatText}>Start Chat</ThemedText>\n        </Pressable>\n\n        <View style={styles.secondaryActions}>\n          <Pressable\n            style={({ pressed }) => [styles.secondaryButton, { opacity: pressed ? 0.7 : 1 }]}\n            onPress={handleReport}\n          >\n            <ThemedText style={[styles.secondaryButtonText, { color: theme.textSecondary }]}>\n              Report Profile\n            </ThemedText>\n          </Pressable>\n\n          <Pressable\n            style={({ pressed }) => [styles.secondaryButton, { opacity: pressed ? 0.7 : 1 }]}\n            onPress={handleBlock}\n          >\n            <ThemedText style={[styles.secondaryButtonText, { color: theme.error }]}>\n              Block User\n            </ThemedText>\n          </Pressable>\n        </View>\n      </View>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  loadingContainer: {\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  photo: {\n    width: SCREEN_WIDTH,\n    height: SCREEN_WIDTH * 0.75,\n  },\n  pagination: {\n    flexDirection: \"row\",\n    justifyContent: \"center\",\n    gap: Spacing.sm,\n    paddingVertical: Spacing.lg,\n  },\n  paginationDot: {\n    width: 8,\n    height: 8,\n    borderRadius: 4,\n  },\n  profileInfo: {\n    paddingHorizontal: Spacing.xl,\n  },\n  nameRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n    marginBottom: Spacing.sm,\n  },\n  userName: {\n    ...Typography.h3,\n  },\n  verificationLabelContainer: {\n    marginBottom: Spacing.md,\n  },\n  languageRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n    marginBottom: Spacing.xl,\n  },\n  languages: {\n    ...Typography.body,\n  },\n  section: {\n    borderRadius: BorderRadius.sm,\n    padding: Spacing.lg,\n    marginBottom: Spacing.lg,\n  },\n  sectionTitle: {\n    ...Typography.small,\n    fontWeight: \"600\",\n    marginBottom: Spacing.sm,\n  },\n  sectionContent: {\n    ...Typography.body,\n  },\n  actionBar: {\n    paddingHorizontal: Spacing.xl,\n    paddingTop: Spacing.lg,\n    borderTopWidth: 1,\n    borderTopColor: \"transparent\",\n  },\n  startChatButton: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.sm,\n    gap: Spacing.sm,\n  },\n  startChatText: {\n    ...Typography.body,\n    fontWeight: \"600\",\n    color: \"#FFFFFF\",\n  },\n  secondaryActions: {\n    flexDirection: \"row\",\n    justifyContent: \"center\",\n    gap: Spacing[\"3xl\"],\n    marginTop: Spacing.lg,\n  },\n  secondaryButton: {\n    padding: Spacing.sm,\n  },\n  secondaryButtonText: {\n    ...Typography.small,\n  },\n});\n","path":null,"size_bytes":11839,"size_tokens":null},"client/screens/ProfileScreen.tsx":{"content":"import React, { useCallback } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  ScrollView,\n  Pressable,\n  Image,\n  Alert,\n  Switch,\n  Platform,\n} from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useBottomTabBarHeight } from \"@react-navigation/bottom-tabs\";\nimport { useNavigation } from \"@react-navigation/native\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useAuth } from \"@/contexts/AuthContext\";\nimport { useNotifications } from \"@/contexts/NotificationContext\";\nimport { Colors, Spacing, BorderRadius, Typography } from \"@/constants/theme\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { getApiUrl } from \"@/lib/query-client\";\nimport type { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport type { RootStackParamList } from \"@/navigation/RootStackNavigator\";\n\ntype NavigationProp = NativeStackNavigationProp<RootStackParamList>;\n\nexport default function ProfileScreen() {\n  const insets = useSafeAreaInsets();\n  const tabBarHeight = useBottomTabBarHeight();\n  const { theme } = useTheme();\n  const { user, logout } = useAuth();\n  const navigation = useNavigation<NavigationProp>();\n  const { notificationsEnabled, requestPermissions, disableNotifications } = useNotifications();\n\n  const getAvatarSource = useCallback(() => {\n    if (!user) return require(\"../../assets/avatars/avatar1.png\");\n    \n    const photos = user.photos || [];\n    const avatarIndex = user.avatarIndex || 0;\n    const photo = photos[avatarIndex] || photos[0];\n    \n    if (photo) {\n      if (photo.startsWith(\"/avatars/\")) {\n        const avatarMap: Record<string, any> = {\n          \"/avatars/avatar1.png\": require(\"../../assets/avatars/avatar1.png\"),\n          \"/avatars/avatar2.png\": require(\"../../assets/avatars/avatar2.png\"),\n          \"/avatars/avatar3.png\": require(\"../../assets/avatars/avatar3.png\"),\n          \"/avatars/avatar4.png\": require(\"../../assets/avatars/avatar4.png\"),\n          \"/avatars/avatar5.png\": require(\"../../assets/avatars/avatar5.png\"),\n          \"/avatars/avatar6.png\": require(\"../../assets/avatars/avatar6.png\"),\n        };\n        return avatarMap[photo] || require(\"../../assets/avatars/avatar1.png\");\n      }\n      return { uri: new URL(photo.startsWith(\"/objects/\") ? photo : `/objects/${photo}`, getApiUrl()).toString() };\n    }\n    return require(\"../../assets/avatars/avatar1.png\");\n  }, [user]);\n\n  const handleLogout = () => {\n    Alert.alert(\n      \"Log Out\",\n      \"Are you sure you want to log out?\",\n      [\n        { text: \"Cancel\", style: \"cancel\" },\n        { text: \"Log Out\", style: \"destructive\", onPress: logout },\n      ]\n    );\n  };\n\n  const handleNotificationToggle = async (value: boolean) => {\n    if (value) {\n      if (Platform.OS === \"web\") {\n        Alert.alert(\"Notifications\", \"Push notifications are only available in the mobile app. Please use Expo Go on your device.\");\n        return;\n      }\n      const granted = await requestPermissions();\n      if (!granted) {\n        Alert.alert(\"Notifications\", \"Please enable notifications in your device settings to receive message alerts.\");\n      }\n    } else {\n      await disableNotifications();\n    }\n  };\n\n  const renderSettingsItem = (\n    icon: keyof typeof Feather.glyphMap,\n    label: string,\n    onPress: () => void,\n    danger?: boolean\n  ) => (\n    <Pressable\n      style={({ pressed }) => [\n        styles.settingsItem,\n        { backgroundColor: theme.cardBackground, opacity: pressed ? 0.95 : 1 },\n      ]}\n      onPress={onPress}\n    >\n      <Feather name={icon} size={20} color={danger ? theme.error : theme.text} />\n      <ThemedText style={[styles.settingsLabel, danger && { color: theme.error }]}>\n        {label}\n      </ThemedText>\n      <Feather name=\"chevron-right\" size={20} color={theme.textSecondary} />\n    </Pressable>\n  );\n\n  const renderNotificationToggle = () => (\n    <View style={[styles.settingsItem, { backgroundColor: theme.cardBackground }]}>\n      <Feather name=\"bell\" size={20} color={theme.text} />\n      <ThemedText style={styles.settingsLabel}>Notifications</ThemedText>\n      <Switch\n        value={notificationsEnabled}\n        onValueChange={handleNotificationToggle}\n        trackColor={{ false: theme.border, true: theme.primary }}\n        thumbColor={Platform.OS === \"android\" ? (notificationsEnabled ? theme.primary : theme.textSecondary) : undefined}\n      />\n    </View>\n  );\n\n  if (!user) return null;\n\n  return (\n    <ThemedView style={styles.container}>\n      <ScrollView\n        contentContainerStyle={[\n          styles.content,\n          { paddingTop: insets.top + Spacing.lg, paddingBottom: tabBarHeight + Spacing.xl },\n        ]}\n        showsVerticalScrollIndicator={false}\n      >\n        <View style={styles.header}>\n          <ThemedText style={styles.headerTitle}>Profile</ThemedText>\n        </View>\n\n        <View style={styles.profileSection}>\n          <Image source={getAvatarSource()} style={styles.avatar} />\n          <ThemedText style={styles.userName}>\n            {user.name}{user.age ? `, ${user.age}` : \"\"}\n          </ThemedText>\n          {user.nativeLanguage && (\n            <ThemedText style={[styles.languages, { color: theme.textSecondary }]}>\n              {user.nativeLanguage} {\"\\u2192\"} {(user.learningLanguages || []).join(\", \")}\n            </ThemedText>\n          )}\n        </View>\n\n        <Pressable\n          style={({ pressed }) => [\n            styles.editButton,\n            { backgroundColor: theme.primary, opacity: pressed ? 0.9 : 1 },\n          ]}\n          onPress={() => navigation.navigate(\"EditProfile\")}\n        >\n          <Feather name=\"edit-2\" size={18} color=\"#FFFFFF\" />\n          <ThemedText style={styles.editButtonText}>Edit Profile</ThemedText>\n        </Pressable>\n\n        {(user.hobbies || user.topics) && (\n          <View style={[styles.infoSection, { backgroundColor: theme.cardBackground }]}>\n            {user.hobbies && (\n              <View style={styles.infoItem}>\n                <ThemedText style={[styles.infoLabel, { color: theme.textSecondary }]}>\n                  Hobbies\n                </ThemedText>\n                <ThemedText style={styles.infoValue}>{user.hobbies}</ThemedText>\n              </View>\n            )}\n            {user.topics && (\n              <View style={styles.infoItem}>\n                <ThemedText style={[styles.infoLabel, { color: theme.textSecondary }]}>\n                  Topics of Interest\n                </ThemedText>\n                <ThemedText style={styles.infoValue}>{user.topics}</ThemedText>\n              </View>\n            )}\n          </View>\n        )}\n\n        <View style={styles.settingsSection}>\n          <ThemedText style={[styles.sectionTitle, { color: theme.textSecondary }]}>\n            Settings\n          </ThemedText>\n          {renderNotificationToggle()}\n          {renderSettingsItem(\"globe\", \"Language Preferences\", () => {})}\n          {renderSettingsItem(\"shield\", \"Privacy\", () => {})}\n          {renderSettingsItem(\"help-circle\", \"Help & Support\", () => {})}\n        </View>\n\n        <View style={styles.settingsSection}>\n          <ThemedText style={[styles.sectionTitle, { color: theme.textSecondary }]}>\n            Account\n          </ThemedText>\n          {renderSettingsItem(\"log-out\", \"Log Out\", handleLogout, true)}\n        </View>\n      </ScrollView>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  content: {\n    paddingHorizontal: Spacing.xl,\n  },\n  header: {\n    marginBottom: Spacing.xl,\n  },\n  headerTitle: {\n    ...Typography.h3,\n  },\n  profileSection: {\n    alignItems: \"center\",\n    marginBottom: Spacing.xl,\n  },\n  avatar: {\n    width: 100,\n    height: 100,\n    borderRadius: 50,\n    marginBottom: Spacing.lg,\n  },\n  userName: {\n    ...Typography.h4,\n    marginBottom: Spacing.xs,\n  },\n  languages: {\n    ...Typography.body,\n  },\n  editButton: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    height: Spacing.buttonHeight,\n    borderRadius: BorderRadius.sm,\n    gap: Spacing.sm,\n    marginBottom: Spacing[\"2xl\"],\n  },\n  editButtonText: {\n    ...Typography.body,\n    fontWeight: \"600\",\n    color: \"#FFFFFF\",\n  },\n  infoSection: {\n    borderRadius: BorderRadius.sm,\n    padding: Spacing.lg,\n    marginBottom: Spacing[\"2xl\"],\n    gap: Spacing.lg,\n  },\n  infoItem: {\n    gap: Spacing.xs,\n  },\n  infoLabel: {\n    ...Typography.small,\n    fontWeight: \"500\",\n  },\n  infoValue: {\n    ...Typography.body,\n  },\n  settingsSection: {\n    marginBottom: Spacing[\"2xl\"],\n  },\n  sectionTitle: {\n    ...Typography.small,\n    fontWeight: \"600\",\n    textTransform: \"uppercase\",\n    marginBottom: Spacing.md,\n    marginLeft: Spacing.sm,\n  },\n  settingsItem: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    padding: Spacing.lg,\n    borderRadius: BorderRadius.sm,\n    marginBottom: Spacing.sm,\n    gap: Spacing.lg,\n  },\n  settingsLabel: {\n    ...Typography.body,\n    flex: 1,\n  },\n});\n","path":null,"size_bytes":9065,"size_tokens":null},"server/db.ts":{"content":"import { drizzle } from \"drizzle-orm/node-postgres\";\nimport pg from \"pg\";\nimport * as schema from \"@shared/schema\";\n\nconst { Pool } = pg;\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\n    \"DATABASE_URL must be set. Did you forget to provision a database?\",\n  );\n}\n\nexport const pool = new Pool({ connectionString: process.env.DATABASE_URL });\nexport const db = drizzle(pool, { schema });\n","path":null,"size_bytes":395,"size_tokens":null},"client/constants/theme.ts":{"content":"import { Platform } from \"react-native\";\n\nconst primaryColor = \"#4A90E2\";\nconst primaryDark = \"#3A7BC8\";\nconst secondaryColor = \"#7B68EE\";\nconst successColor = \"#4CAF50\";\nconst errorColor = \"#F44336\";\n\nexport const Colors = {\n  light: {\n    text: \"#212121\",\n    textSecondary: \"#757575\",\n    buttonText: \"#FFFFFF\",\n    tabIconDefault: \"#687076\",\n    tabIconSelected: primaryColor,\n    link: primaryColor,\n    primary: primaryColor,\n    primaryDark: primaryDark,\n    secondary: secondaryColor,\n    success: successColor,\n    error: errorColor,\n    online: successColor,\n    backgroundRoot: \"#FFFFFF\",\n    backgroundDefault: \"#F5F5F5\",\n    backgroundSecondary: \"#E8E8E8\",\n    backgroundTertiary: \"#D9D9D9\",\n    border: \"#E0E0E0\",\n    cardBackground: \"#FFFFFF\",\n    inputBackground: \"#F5F5F5\",\n    messageSent: primaryColor,\n    messageReceived: \"#F0F0F0\",\n  },\n  dark: {\n    text: \"#ECEDEE\",\n    textSecondary: \"#9BA1A6\",\n    buttonText: \"#FFFFFF\",\n    tabIconDefault: \"#9BA1A6\",\n    tabIconSelected: \"#0A84FF\",\n    link: \"#0A84FF\",\n    primary: \"#0A84FF\",\n    primaryDark: \"#0066CC\",\n    secondary: \"#9D8DF1\",\n    success: \"#66BB6A\",\n    error: \"#EF5350\",\n    online: \"#66BB6A\",\n    backgroundRoot: \"#1F2123\",\n    backgroundDefault: \"#2A2C2E\",\n    backgroundSecondary: \"#353739\",\n    backgroundTertiary: \"#404244\",\n    border: \"#404244\",\n    cardBackground: \"#2A2C2E\",\n    inputBackground: \"#353739\",\n    messageSent: \"#0A84FF\",\n    messageReceived: \"#353739\",\n  },\n};\n\nexport const Spacing = {\n  xs: 4,\n  sm: 8,\n  md: 12,\n  lg: 16,\n  xl: 20,\n  \"2xl\": 24,\n  \"3xl\": 32,\n  \"4xl\": 40,\n  \"5xl\": 48,\n  inputHeight: 48,\n  buttonHeight: 52,\n};\n\nexport const BorderRadius = {\n  xs: 8,\n  sm: 12,\n  md: 18,\n  lg: 24,\n  xl: 30,\n  \"2xl\": 40,\n  \"3xl\": 50,\n  full: 9999,\n};\n\nexport const Typography = {\n  h1: {\n    fontSize: 32,\n    fontWeight: \"700\" as const,\n  },\n  h2: {\n    fontSize: 28,\n    fontWeight: \"700\" as const,\n  },\n  h3: {\n    fontSize: 24,\n    fontWeight: \"600\" as const,\n  },\n  h4: {\n    fontSize: 20,\n    fontWeight: \"600\" as const,\n  },\n  body: {\n    fontSize: 16,\n    fontWeight: \"400\" as const,\n  },\n  small: {\n    fontSize: 14,\n    fontWeight: \"400\" as const,\n  },\n  caption: {\n    fontSize: 12,\n    fontWeight: \"400\" as const,\n  },\n  link: {\n    fontSize: 16,\n    fontWeight: \"400\" as const,\n  },\n};\n\nexport const Fonts = Platform.select({\n  ios: {\n    sans: \"system-ui\",\n    serif: \"ui-serif\",\n    rounded: \"ui-rounded\",\n    mono: \"ui-monospace\",\n  },\n  default: {\n    sans: \"normal\",\n    serif: \"serif\",\n    rounded: \"normal\",\n    mono: \"monospace\",\n  },\n  web: {\n    sans: \"system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif\",\n    serif: \"Georgia, 'Times New Roman', serif\",\n    rounded:\n      \"'SF Pro Rounded', 'Hiragino Maru Gothic ProN', Meiryo, 'MS PGothic', sans-serif\",\n    mono: \"SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace\",\n  },\n});\n","path":null,"size_bytes":2938,"size_tokens":null},"client/index.js":{"content":"import { registerRootComponent } from \"expo\";\n\nimport App from \"@/App\";\n\nregisterRootComponent(App);\n","path":null,"size_bytes":101,"size_tokens":null},"client/screens/ChatScreen.tsx":{"content":"import React, { useState, useCallback, useRef, useEffect } from \"react\";\nimport {\n  View,\n  StyleSheet,\n  FlatList,\n  TextInput,\n  Pressable,\n  Image,\n  ActivityIndicator,\n  Alert,\n  Modal,\n  Platform,\n} from \"react-native\";\nimport { useSafeAreaInsets } from \"react-native-safe-area-context\";\nimport { useNavigation, useRoute, type RouteProp } from \"@react-navigation/native\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport * as Clipboard from \"expo-clipboard\";\nimport * as Haptics from \"expo-haptics\";\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { ThemedView } from \"@/components/ThemedView\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { useAuth } from \"@/contexts/AuthContext\";\nimport { Spacing, BorderRadius, Typography } from \"@/constants/theme\";\nimport { Feather } from \"@expo/vector-icons\";\nimport { getApiUrl } from \"@/lib/query-client\";\nimport type { Message, User } from \"@shared/schema\";\nimport type { NativeStackNavigationProp } from \"@react-navigation/native-stack\";\nimport type { RootStackParamList } from \"@/navigation/RootStackNavigator\";\n\ntype NavigationProp = NativeStackNavigationProp<RootStackParamList>;\ntype ChatRouteProp = RouteProp<RootStackParamList, \"Chat\">;\n\ninterface TranslationResult {\n  translatedText: string;\n  sourceLanguage: string;\n}\n\nexport default function ChatScreen() {\n  const insets = useSafeAreaInsets();\n  const { theme } = useTheme();\n  const { token, user: currentUser } = useAuth();\n  const navigation = useNavigation<NavigationProp>();\n  const route = useRoute<ChatRouteProp>();\n  const queryClient = useQueryClient();\n  const flatListRef = useRef<FlatList>(null);\n\n  const { user: chatUser } = route.params;\n  const [message, setMessage] = useState(\"\");\n  const [selectedMessage, setSelectedMessage] = useState<Message | null>(null);\n  const [showContextMenu, setShowContextMenu] = useState(false);\n  const [translatedText, setTranslatedText] = useState<string | null>(null);\n\n  useEffect(() => {\n    navigation.setOptions({\n      headerTitle: () => (\n        <Pressable\n          style={styles.headerTitle}\n          onPress={() => navigation.navigate(\"UserProfile\", { userId: chatUser.id })}\n        >\n          <Image source={getAvatarSource(chatUser)} style={styles.headerAvatar} />\n          <View>\n            <ThemedText style={styles.headerName}>{chatUser.name}</ThemedText>\n            {chatUser.isOnline && (\n              <ThemedText style={[styles.headerStatus, { color: theme.online }]}>Online</ThemedText>\n            )}\n          </View>\n        </Pressable>\n      ),\n    });\n  }, [navigation, chatUser, theme]);\n\n  const { data: messages = [], isLoading } = useQuery<Message[]>({\n    queryKey: [\"/api/messages\", chatUser.id],\n    queryFn: async () => {\n      const response = await fetch(\n        new URL(`/api/messages/${chatUser.id}`, getApiUrl()).toString(),\n        { headers: { Authorization: `Bearer ${token}` } }\n      );\n      if (!response.ok) throw new Error(\"Failed to fetch messages\");\n      return response.json();\n    },\n    refetchInterval: 3000,\n  });\n\n  const sendMutation = useMutation({\n    mutationFn: async (content: string) => {\n      const response = await fetch(new URL(\"/api/messages\", getApiUrl()).toString(), {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${token}`,\n        },\n        body: JSON.stringify({ receiverId: chatUser.id, content }),\n      });\n      if (!response.ok) throw new Error(\"Failed to send message\");\n      return response.json();\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: [\"/api/messages\", chatUser.id] });\n      queryClient.invalidateQueries({ queryKey: [\"/api/conversations\"] });\n      setMessage(\"\");\n    },\n  });\n\n  const translateMutation = useMutation({\n    mutationFn: async (text: string): Promise<TranslationResult> => {\n      const response = await fetch(new URL(\"/api/translate\", getApiUrl()).toString(), {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${token}`,\n        },\n        body: JSON.stringify({\n          text,\n          targetLanguage: currentUser?.nativeLanguage || \"English\",\n        }),\n      });\n      if (!response.ok) throw new Error(\"Translation failed\");\n      return response.json();\n    },\n    onSuccess: (data) => {\n      setTranslatedText(data.translatedText);\n    },\n    onError: () => {\n      Alert.alert(\"Translation Failed\", \"Unable to translate this message.\");\n    },\n  });\n\n  const reportMutation = useMutation({\n    mutationFn: async (messageId: string) => {\n      const response = await fetch(\n        new URL(`/api/messages/${messageId}/report`, getApiUrl()).toString(),\n        { method: \"POST\", headers: { Authorization: `Bearer ${token}` } }\n      );\n      if (!response.ok) throw new Error(\"Failed to report message\");\n    },\n    onSuccess: () => {\n      Alert.alert(\"Message Reported\", \"Thank you for reporting this message.\");\n      setShowContextMenu(false);\n      setSelectedMessage(null);\n    },\n  });\n\n  const getAvatarSource = useCallback((user: User) => {\n    const photos = user.photos || [];\n    const avatarIndex = user.avatarIndex || 0;\n    const photo = photos[avatarIndex] || photos[0];\n    \n    if (photo) {\n      if (photo.startsWith(\"/avatars/\")) {\n        const avatarMap: Record<string, any> = {\n          \"/avatars/avatar1.png\": require(\"../../assets/avatars/avatar1.png\"),\n          \"/avatars/avatar2.png\": require(\"../../assets/avatars/avatar2.png\"),\n          \"/avatars/avatar3.png\": require(\"../../assets/avatars/avatar3.png\"),\n          \"/avatars/avatar4.png\": require(\"../../assets/avatars/avatar4.png\"),\n          \"/avatars/avatar5.png\": require(\"../../assets/avatars/avatar5.png\"),\n          \"/avatars/avatar6.png\": require(\"../../assets/avatars/avatar6.png\"),\n        };\n        return avatarMap[photo] || require(\"../../assets/avatars/avatar1.png\");\n      }\n      return { uri: new URL(photo.startsWith(\"/objects/\") ? photo : `/objects/${photo}`, getApiUrl()).toString() };\n    }\n    return require(\"../../assets/avatars/avatar1.png\");\n  }, []);\n\n  const handleLongPress = (msg: Message) => {\n    if (Platform.OS !== \"web\") {\n      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n    }\n    setSelectedMessage(msg);\n    setTranslatedText(null);\n    setShowContextMenu(true);\n  };\n\n  const handleCopy = async () => {\n    if (selectedMessage) {\n      await Clipboard.setStringAsync(selectedMessage.content);\n      setShowContextMenu(false);\n      setSelectedMessage(null);\n    }\n  };\n\n  const handleTranslate = () => {\n    if (selectedMessage) {\n      translateMutation.mutate(selectedMessage.content);\n    }\n  };\n\n  const handleReport = () => {\n    if (selectedMessage) {\n      Alert.alert(\n        \"Report Message\",\n        \"Are you sure you want to report this message?\",\n        [\n          { text: \"Cancel\", style: \"cancel\" },\n          { text: \"Report\", style: \"destructive\", onPress: () => reportMutation.mutate(selectedMessage.id) },\n        ]\n      );\n    }\n  };\n\n  const handleSend = () => {\n    if (message.trim()) {\n      sendMutation.mutate(message.trim());\n    }\n  };\n\n  const formatTime = (date: Date | string) => {\n    return new Date(date).toLocaleTimeString([], { hour: \"2-digit\", minute: \"2-digit\" });\n  };\n\n  const renderMessage = ({ item, index }: { item: Message; index: number }) => {\n    const isSent = item.senderId === currentUser?.id;\n    const showAvatar = !isSent && (index === 0 || messages[index - 1]?.senderId !== item.senderId);\n\n    return (\n      <Pressable\n        onLongPress={() => handleLongPress(item)}\n        style={[styles.messageRow, isSent && styles.messageRowSent]}\n      >\n        {!isSent && (\n          <View style={styles.avatarPlaceholder}>\n            {showAvatar && <Image source={getAvatarSource(chatUser)} style={styles.messageAvatar} />}\n          </View>\n        )}\n        <View\n          style={[\n            styles.messageBubble,\n            isSent\n              ? { backgroundColor: theme.messageSent }\n              : { backgroundColor: theme.messageReceived },\n          ]}\n        >\n          <ThemedText style={[styles.messageText, isSent && { color: \"#FFFFFF\" }]}>\n            {item.content}\n          </ThemedText>\n          <ThemedText\n            style={[\n              styles.messageTime,\n              { color: isSent ? \"rgba(255,255,255,0.7)\" : theme.textSecondary },\n            ]}\n          >\n            {formatTime(item.createdAt!)}\n          </ThemedText>\n        </View>\n      </Pressable>\n    );\n  };\n\n  if (isLoading) {\n    return (\n      <ThemedView style={[styles.container, styles.loadingContainer]}>\n        <ActivityIndicator size=\"large\" color={theme.primary} />\n      </ThemedView>\n    );\n  }\n\n  return (\n    <ThemedView style={styles.container}>\n      <FlatList\n        ref={flatListRef}\n        data={messages}\n        renderItem={renderMessage}\n        keyExtractor={(item) => item.id}\n        contentContainerStyle={styles.messageList}\n        showsVerticalScrollIndicator={false}\n        inverted={false}\n        onContentSizeChange={() => flatListRef.current?.scrollToEnd({ animated: true })}\n        ListEmptyComponent={\n          <View style={styles.emptyContainer}>\n            <Feather name=\"message-circle\" size={48} color={theme.textSecondary} />\n            <ThemedText style={[styles.emptyText, { color: theme.textSecondary }]}>\n              Start the conversation\n            </ThemedText>\n          </View>\n        }\n      />\n\n      <View style={[styles.inputBar, { paddingBottom: insets.bottom + Spacing.sm, backgroundColor: theme.backgroundRoot }]}>\n        <TextInput\n          style={[styles.input, { backgroundColor: theme.inputBackground, color: theme.text }]}\n          placeholder=\"Type a message...\"\n          placeholderTextColor={theme.textSecondary}\n          value={message}\n          onChangeText={setMessage}\n          multiline\n          maxLength={1000}\n        />\n        <Pressable\n          style={({ pressed }) => [\n            styles.sendButton,\n            { backgroundColor: theme.primary, opacity: message.trim() ? (pressed ? 0.8 : 1) : 0.5 },\n          ]}\n          onPress={handleSend}\n          disabled={!message.trim() || sendMutation.isPending}\n        >\n          {sendMutation.isPending ? (\n            <ActivityIndicator size=\"small\" color=\"#FFFFFF\" />\n          ) : (\n            <Feather name=\"send\" size={20} color=\"#FFFFFF\" />\n          )}\n        </Pressable>\n      </View>\n\n      <Modal visible={showContextMenu} animationType=\"fade\" transparent>\n        <Pressable\n          style={styles.modalOverlay}\n          onPress={() => {\n            setShowContextMenu(false);\n            setSelectedMessage(null);\n            setTranslatedText(null);\n          }}\n        >\n          <View style={[styles.contextMenu, { backgroundColor: theme.backgroundRoot }]}>\n            {translatedText && (\n              <View style={[styles.translationResult, { borderBottomColor: theme.border }]}>\n                <ThemedText style={styles.translationText}>{translatedText}</ThemedText>\n              </View>\n            )}\n\n            <Pressable\n              style={({ pressed }) => [styles.contextMenuItem, { opacity: pressed ? 0.7 : 1 }]}\n              onPress={handleTranslate}\n            >\n              <Feather name=\"globe\" size={20} color={theme.primary} />\n              <ThemedText style={[styles.contextMenuText, { color: theme.primary }]}>\n                {translateMutation.isPending ? \"Translating...\" : `Translate to ${currentUser?.nativeLanguage || \"English\"}`}\n              </ThemedText>\n            </Pressable>\n\n            <Pressable\n              style={({ pressed }) => [styles.contextMenuItem, { opacity: pressed ? 0.7 : 1 }]}\n              onPress={handleCopy}\n            >\n              <Feather name=\"copy\" size={20} color={theme.text} />\n              <ThemedText style={styles.contextMenuText}>Copy</ThemedText>\n            </Pressable>\n\n            {selectedMessage?.senderId !== currentUser?.id && (\n              <Pressable\n                style={({ pressed }) => [styles.contextMenuItem, { opacity: pressed ? 0.7 : 1 }]}\n                onPress={handleReport}\n              >\n                <Feather name=\"flag\" size={20} color={theme.error} />\n                <ThemedText style={[styles.contextMenuText, { color: theme.error }]}>Report</ThemedText>\n              </Pressable>\n            )}\n          </View>\n        </Pressable>\n      </Modal>\n    </ThemedView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  loadingContainer: {\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  headerTitle: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: Spacing.sm,\n  },\n  headerAvatar: {\n    width: 32,\n    height: 32,\n    borderRadius: 16,\n  },\n  headerName: {\n    ...Typography.body,\n    fontWeight: \"600\",\n  },\n  headerStatus: {\n    ...Typography.caption,\n  },\n  messageList: {\n    padding: Spacing.lg,\n    flexGrow: 1,\n  },\n  messageRow: {\n    flexDirection: \"row\",\n    marginBottom: Spacing.sm,\n  },\n  messageRowSent: {\n    justifyContent: \"flex-end\",\n  },\n  avatarPlaceholder: {\n    width: 28,\n    marginRight: Spacing.sm,\n  },\n  messageAvatar: {\n    width: 28,\n    height: 28,\n    borderRadius: 14,\n  },\n  messageBubble: {\n    maxWidth: \"75%\",\n    padding: Spacing.md,\n    borderRadius: BorderRadius.md,\n  },\n  messageText: {\n    ...Typography.body,\n  },\n  messageTime: {\n    ...Typography.caption,\n    marginTop: Spacing.xs,\n    alignSelf: \"flex-end\",\n  },\n  emptyContainer: {\n    flex: 1,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n    paddingTop: Spacing[\"5xl\"] * 2,\n  },\n  emptyText: {\n    ...Typography.body,\n    marginTop: Spacing.lg,\n  },\n  inputBar: {\n    flexDirection: \"row\",\n    alignItems: \"flex-end\",\n    padding: Spacing.md,\n    gap: Spacing.sm,\n    borderTopWidth: 1,\n    borderTopColor: \"transparent\",\n  },\n  input: {\n    flex: 1,\n    minHeight: 44,\n    maxHeight: 100,\n    borderRadius: BorderRadius.lg,\n    paddingHorizontal: Spacing.lg,\n    paddingVertical: Spacing.md,\n    ...Typography.body,\n  },\n  sendButton: {\n    width: 44,\n    height: 44,\n    borderRadius: 22,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  modalOverlay: {\n    flex: 1,\n    backgroundColor: \"rgba(0,0,0,0.5)\",\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  contextMenu: {\n    borderRadius: BorderRadius.md,\n    paddingVertical: Spacing.sm,\n    minWidth: 250,\n    overflow: \"hidden\",\n  },\n  translationResult: {\n    padding: Spacing.lg,\n    borderBottomWidth: 1,\n  },\n  translationText: {\n    ...Typography.body,\n    fontStyle: \"italic\",\n  },\n  contextMenuItem: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    padding: Spacing.lg,\n    gap: Spacing.lg,\n  },\n  contextMenuText: {\n    ...Typography.body,\n  },\n});\n","path":null,"size_bytes":14933,"size_tokens":null},"babel.config.js":{"content":"module.exports = function (api) {\n  api.cache(true);\n  return {\n    presets: [\"babel-preset-expo\"],\n    plugins: [\n      [\n        \"module-resolver\",\n        {\n          root: [\"./\"],\n          alias: {\n            \"@\": \"./client\",\n            \"@shared\": \"./shared\",\n          },\n          extensions: [\".ios.js\", \".android.js\", \".js\", \".ts\", \".tsx\", \".json\"],\n        },\n      ],\n      \"react-native-reanimated/plugin\",\n    ],\n  };\n};\n","path":null,"size_bytes":436,"size_tokens":null},"drizzle.config.ts":{"content":"import { defineConfig } from \"drizzle-kit\";\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\"DATABASE_URL, ensure the database is provisioned\");\n}\n\nexport default defineConfig({\n  out: \"./migrations\",\n  schema: \"./shared/schema.ts\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL,\n  },\n});\n","path":null,"size_bytes":325,"size_tokens":null},"client/components/HeaderTitle.tsx":{"content":"import React from \"react\";\nimport { View, StyleSheet, Image } from \"react-native\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { Spacing } from \"@/constants/theme\";\n\ninterface HeaderTitleProps {\n  title: string;\n}\n\nexport function HeaderTitle({ title }: HeaderTitleProps) {\n  return (\n    <View style={styles.container}>\n      <Image\n        source={require(\"../../assets/images/icon.png\")}\n        style={styles.icon}\n        resizeMode=\"contain\"\n      />\n      <ThemedText style={styles.title}>{title}</ThemedText>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    justifyContent: \"flex-start\",\n  },\n  icon: {\n    width: 28,\n    height: 28,\n    marginRight: Spacing.sm,\n  },\n  title: {\n    fontSize: 17,\n    fontWeight: \"600\",\n  },\n});\n","path":null,"size_bytes":832,"size_tokens":null},"client/components/Card.tsx":{"content":"import React from \"react\";\nimport { StyleSheet, Pressable, ViewStyle } from \"react-native\";\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n  withSpring,\n  WithSpringConfig,\n} from \"react-native-reanimated\";\n\nimport { ThemedText } from \"@/components/ThemedText\";\nimport { useTheme } from \"@/hooks/useTheme\";\nimport { Spacing, BorderRadius } from \"@/constants/theme\";\n\ninterface CardProps {\n  elevation?: number;\n  title?: string;\n  description?: string;\n  children?: React.ReactNode;\n  onPress?: () => void;\n  style?: ViewStyle;\n}\n\nconst springConfig: WithSpringConfig = {\n  damping: 15,\n  mass: 0.3,\n  stiffness: 150,\n  overshootClamping: true,\n  energyThreshold: 0.001,\n};\n\nconst getBackgroundColorForElevation = (\n  elevation: number,\n  theme: any,\n): string => {\n  switch (elevation) {\n    case 1:\n      return theme.backgroundDefault;\n    case 2:\n      return theme.backgroundSecondary;\n    case 3:\n      return theme.backgroundTertiary;\n    default:\n      return theme.backgroundRoot;\n  }\n};\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\nexport function Card({\n  elevation = 1,\n  title,\n  description,\n  children,\n  onPress,\n  style,\n}: CardProps) {\n  const { theme } = useTheme();\n  const scale = useSharedValue(1);\n\n  const cardBackgroundColor = getBackgroundColorForElevation(elevation, theme);\n\n  const animatedStyle = useAnimatedStyle(() => ({\n    transform: [{ scale: scale.value }],\n  }));\n\n  const handlePressIn = () => {\n    scale.value = withSpring(0.98, springConfig);\n  };\n\n  const handlePressOut = () => {\n    scale.value = withSpring(1, springConfig);\n  };\n\n  return (\n    <AnimatedPressable\n      onPress={onPress}\n      onPressIn={handlePressIn}\n      onPressOut={handlePressOut}\n      style={[\n        styles.card,\n        {\n          backgroundColor: cardBackgroundColor,\n        },\n        animatedStyle,\n        style,\n      ]}\n    >\n      {title ? (\n        <ThemedText type=\"h4\" style={styles.cardTitle}>\n          {title}\n        </ThemedText>\n      ) : null}\n      {description ? (\n        <ThemedText type=\"small\" style={styles.cardDescription}>\n          {description}\n        </ThemedText>\n      ) : null}\n      {children}\n    </AnimatedPressable>\n  );\n}\n\nconst styles = StyleSheet.create({\n  card: {\n    padding: Spacing.xl,\n    borderRadius: BorderRadius[\"2xl\"],\n  },\n  cardTitle: {\n    marginBottom: Spacing.sm,\n  },\n  cardDescription: {\n    opacity: 0.7,\n  },\n});\n","path":null,"size_bytes":2437,"size_tokens":null},"client/constants/languages.ts":{"content":"export const LANGUAGES = [\n  { code: 'en', name: 'English', nativeName: 'English' },\n  { code: 'es', name: 'Spanish', nativeName: 'Espaol' },\n  { code: 'fr', name: 'French', nativeName: 'Franais' },\n  { code: 'de', name: 'German', nativeName: 'Deutsch' },\n  { code: 'it', name: 'Italian', nativeName: 'Italiano' },\n  { code: 'pt', name: 'Portuguese', nativeName: 'Portugus' },\n  { code: 'ru', name: 'Russian', nativeName: '' },\n  { code: 'zh', name: 'Chinese', nativeName: '' },\n  { code: 'ja', name: 'Japanese', nativeName: '' },\n  { code: 'ko', name: 'Korean', nativeName: '' },\n  { code: 'ar', name: 'Arabic', nativeName: '' },\n  { code: 'hi', name: 'Hindi', nativeName: '' },\n  { code: 'tr', name: 'Turkish', nativeName: 'Trke' },\n  { code: 'nl', name: 'Dutch', nativeName: 'Nederlands' },\n  { code: 'pl', name: 'Polish', nativeName: 'Polski' },\n  { code: 'sv', name: 'Swedish', nativeName: 'Svenska' },\n  { code: 'da', name: 'Danish', nativeName: 'Dansk' },\n  { code: 'no', name: 'Norwegian', nativeName: 'Norsk' },\n  { code: 'fi', name: 'Finnish', nativeName: 'Suomi' },\n  { code: 'el', name: 'Greek', nativeName: '' },\n  { code: 'he', name: 'Hebrew', nativeName: '' },\n  { code: 'th', name: 'Thai', nativeName: '' },\n  { code: 'vi', name: 'Vietnamese', nativeName: 'Ting Vit' },\n  { code: 'id', name: 'Indonesian', nativeName: 'Bahasa Indonesia' },\n  { code: 'ms', name: 'Malay', nativeName: 'Bahasa Melayu' },\n  { code: 'cs', name: 'Czech', nativeName: 'etina' },\n  { code: 'hu', name: 'Hungarian', nativeName: 'Magyar' },\n  { code: 'ro', name: 'Romanian', nativeName: 'Romn' },\n  { code: 'uk', name: 'Ukrainian', nativeName: '' },\n];\n\nexport function getLanguageCode(languageName: string): string {\n  const language = LANGUAGES.find(\n    l => l.name.toLowerCase() === languageName.toLowerCase() ||\n         l.nativeName.toLowerCase() === languageName.toLowerCase()\n  );\n  return language?.code || 'en';\n}\n\nexport function getLanguageName(code: string): string {\n  const language = LANGUAGES.find(l => l.code === code);\n  return language?.name || code;\n}\n","path":null,"size_bytes":2212,"size_tokens":null},"server/pushNotifications.ts":{"content":"import { storage } from \"./storage\";\n\ninterface ExpoPushMessage {\n  to: string;\n  sound?: string;\n  title?: string;\n  body?: string;\n  data?: Record<string, any>;\n}\n\ninterface ExpoPushTicket {\n  id?: string;\n  status: \"ok\" | \"error\";\n  message?: string;\n  details?: { error?: string };\n}\n\nexport async function sendPushNotification(\n  receiverId: string,\n  title: string,\n  body: string,\n  data?: Record<string, any>\n): Promise<boolean> {\n  try {\n    const receiver = await storage.getUser(receiverId);\n    if (!receiver?.pushToken) {\n      return false;\n    }\n\n    if (!receiver.pushToken.startsWith(\"ExponentPushToken[\")) {\n      console.log(\"Invalid push token format for user:\", receiverId);\n      return false;\n    }\n\n    const message: ExpoPushMessage = {\n      to: receiver.pushToken,\n      sound: \"default\",\n      title,\n      body,\n      data,\n    };\n\n    const response = await fetch(\"https://exp.host/--/api/v2/push/send\", {\n      method: \"POST\",\n      headers: {\n        Accept: \"application/json\",\n        \"Accept-encoding\": \"gzip, deflate\",\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify([message]),\n    });\n\n    const result = await response.json();\n    const tickets = result.data as ExpoPushTicket[];\n\n    if (tickets && tickets.length > 0) {\n      const ticket = tickets[0];\n      if (ticket.status === \"error\") {\n        console.error(\"Push notification error:\", ticket.message, ticket.details);\n        if (ticket.details?.error === \"DeviceNotRegistered\") {\n          await storage.updateUser(receiverId, { pushToken: null as any });\n        }\n        return false;\n      }\n    }\n\n    return true;\n  } catch (error) {\n    console.error(\"Failed to send push notification:\", error);\n    return false;\n  }\n}\n\nexport async function sendNewMessageNotification(\n  senderId: string,\n  receiverId: string,\n  messageContent: string\n): Promise<boolean> {\n  try {\n    const sender = await storage.getUser(senderId);\n    if (!sender) {\n      return false;\n    }\n\n    const truncatedMessage =\n      messageContent.length > 100\n        ? messageContent.substring(0, 100) + \"...\"\n        : messageContent;\n\n    return await sendPushNotification(\n      receiverId,\n      `New message from ${sender.name}`,\n      truncatedMessage,\n      {\n        type: \"new_message\",\n        senderId,\n        senderName: sender.name,\n      }\n    );\n  } catch (error) {\n    console.error(\"Failed to send new message notification:\", error);\n    return false;\n  }\n}\n","path":null,"size_bytes":2484,"size_tokens":null},"design_guidelines.md":{"content":"# LanChat Mobile App - Design Guidelines\n\n## Authentication Architecture\n\n**Email/Password Authentication Required**\n- Use email-based registration and login (NOT SSO)\n- Welcome screen displays \"Welcome to LanChat\" branding\n- Registration flow  Onboarding (language selection)  Profile setup\n- Login screen: email field, password field, \"Sign In\" button, \"Create Account\" link\n- Include \"Forgot Password\" link for password recovery\n\n## Navigation Structure\n\n**Tab Navigation (3 tabs)**\n- Community (center focus) - Main discovery tab\n- Chats - Message conversations\n- Profile - User settings and profile management\n\n## Screen Specifications\n\n### 1. Welcome/Login Screen\n- **Layout**: Full-screen with branding\n- **Header**: None (full splash design)\n- **Content**:\n  - \"Welcome to LanChat\" hero text (large, centered)\n  - Email input field with icon\n  - Password input field with icon, show/hide toggle\n  - \"Sign In\" primary button (full-width)\n  - \"Create Account\" text link below\n  - \"Forgot Password?\" link at bottom\n- **Safe Area**: Standard insets (top + bottom)\n\n### 2. Registration & Onboarding Flow\n- **Step 1**: Email/password registration with confirmation\n- **Step 2**: Select native language (searchable dropdown/modal)\n- **Step 3**: Select languages to learn (multi-select with chips)\n- Progress indicator showing 2/2 or 3/3 steps\n- \"Continue\" button becomes active when requirements met\n\n### 3. Profile Setup/Edit Screen\n- **Header**: \"Edit Profile\" with Save (right) and Cancel (left) buttons\n- **Layout**: Scrollable form\n- **Photo Section**:\n  - 4 photo upload slots in horizontal scrollable gallery\n  - First photo is default avatar (marked with star icon)\n  - Tap any photo to set as avatar\n  - Empty slots show \"+\" icon to add photo\n  - Each slot: 120x120dp rounded square\n- **Form Fields**:\n  - Display name\n  - Native language (tap to change)\n  - Learning languages (tap to modify)\n  - Hobbies (multi-line text input)\n  - Topics of interest (multi-line text input)\n  - Age (number picker)\n- **Safe Area**: Top: headerHeight + Spacing.xl, Bottom: insets.bottom + Spacing.xl\n\n### 4. Community Tab\n- **Header**: Transparent header with \"Community\" title and filter icon (right)\n- **Filter Bar**: Horizontal scrollable pills below header\n  - \"All Members\" (default selected)\n  - \"New Members\"\n  - \"Online\" toggle indicator\n- **Age Filter**: Separate modal/sheet\n  - Dual-handle range slider (18-65 years)\n  - \"Apply\" and \"Reset\" buttons\n- **User List**: Vertical scrollable cards\n  - Each card shows:\n    - Profile photo (left, 60x60dp circular)\n    - Name and age (top right)\n    - Native language  Learning language (small text)\n    - Online status indicator (green dot if online)\n    - Chat button (bottom right, icon only)\n  - Visual feedback on card press\n- **Safe Area**: Top: headerHeight + Spacing.xl, Bottom: tabBarHeight + Spacing.xl\n- **Mock Users**: Include 5-8 bot profiles with diverse photos, names, and language pairs\n\n### 5. User Profile View (Modal/Screen)\n- **Header**: Back button (left), More menu (right: Report, Block)\n- **Layout**: Scrollable with hero photo section\n- **Photo Gallery**: \n  - Swipeable horizontal pager showing all 4 photos\n  - Pagination dots below\n  - Full-width photos (aspect ratio 4:3)\n- **Profile Info Section**:\n  - Name and age (large text)\n  - Native language  Learning languages\n  - Hobbies section with chips/tags\n  - Topics of interest section with chips/tags\n- **Action Buttons** (bottom, above safe area):\n  - \"Start Chat\" primary button (full-width)\n  - \"Report Profile\" secondary button (text only, smaller)\n  - \"Block User\" secondary button (text only, smaller, red)\n- **Safe Area**: Bottom: insets.bottom + Spacing.xl\n\n### 6. Chats Tab\n- **Header**: \"Chats\" title, search icon (right)\n- **List**: Conversation previews\n  - Avatar (left, 50x50dp)\n  - Name and last message preview\n  - Timestamp (right)\n  - Unread badge if applicable\n  - Swipe actions: Archive, Delete\n- **Empty State**: Friendly illustration with \"Start a conversation in Community\"\n- **Safe Area**: Top: headerHeight + Spacing.xl, Bottom: tabBarHeight + Spacing.xl\n\n### 7. Chat Screen\n- **Header**: User avatar + name (center), back (left), more menu (right)\n- **Messages**: \n  - Sender bubbles aligned right (primary color)\n  - Receiver bubbles aligned left (light gray)\n  - Timestamp below each message group\n  - Avatar shown for receiver messages\n- **Long-Press Menu** (context menu):\n  - \"Translate to [Native Language]\" (with globe icon)\n  - \"Copy\" (with copy icon)\n  - \"Report\" (with flag icon, red text)\n- **Input Bar** (sticky bottom):\n  - Text input field (multi-line, max 4 lines)\n  - Send button (icon, disabled when empty)\n- **Safe Area**: Top: headerHeight, Bottom: insets.bottom + input height\n\n### 8. Profile Tab (Own Profile)\n- **Header**: \"Profile\" title, settings icon (right)\n- **Layout**: Scrollable\n- **Photo Section**: Same as profile view but read-only display\n- **Info Display**: Name, languages, hobbies, topics\n- **Edit Profile Button**: Prominent, below info section\n- **Settings Section**: \n  - Notification preferences\n  - Language settings\n  - Privacy settings\n  - Log out\n  - Delete account (nested, with confirmation)\n- **Safe Area**: Top: headerHeight + Spacing.xl, Bottom: tabBarHeight + Spacing.xl\n\n## Design System\n\n### Colors\n- **Primary**: #4A90E2 (blue, for language/learning theme)\n- **Secondary**: #7B68EE (purple accent)\n- **Success/Online**: #4CAF50 (green)\n- **Error/Report**: #F44336 (red)\n- **Text Primary**: #212121\n- **Text Secondary**: #757575\n- **Background**: #FFFFFF\n- **Surface**: #F5F5F5\n- **Border**: #E0E0E0\n\n### Typography\n- **Hero/Welcome**: 32pt, bold\n- **Screen Titles**: 24pt, semi-bold\n- **User Names**: 18pt, medium\n- **Body Text**: 16pt, regular\n- **Captions/Metadata**: 14pt, regular\n- **Buttons**: 16pt, semi-bold\n\n### Spacing\n- xs: 4dp\n- sm: 8dp\n- md: 16dp\n- lg: 24dp\n- xl: 32dp\n\n### Components\n- **Buttons**: Rounded corners (8dp), minimum height 48dp\n- **Input Fields**: Outlined style, 12dp radius, 48dp height\n- **Cards**: Elevated with subtle shadow (2dp offset, 0.10 opacity, 3dp radius)\n- **Avatars**: Circular with 2dp border in surface color\n- **Photos**: Rounded corners (12dp for galleries, 8dp for thumbnails)\n- **Chips/Tags**: Pill-shaped (24dp radius), small padding (8dp horizontal)\n\n### Interaction Patterns\n- All touchable elements: Scale down (0.97) on press\n- List items: Ripple effect on Android, subtle highlight on iOS\n- Floating action button (chat icon): Shadow (offset 0,2, opacity 0.10, radius 2)\n- Modals: Slide up from bottom with backdrop (0.5 opacity black)\n- Long-press: Haptic feedback + context menu after 500ms\n- Photo upload: Native image picker with crop option\n\n### Assets Required\n- **App Icon**: LanChat logo (globe + chat bubble concept)\n- **Bot Avatars**: Generate 5-8 diverse, friendly avatar illustrations\n  - Mix of genders and ethnicities\n  - Consistent art style (flat, friendly, modern)\n  - Warm, welcoming expressions\n- **Empty State Illustrations**: \n  - No chats yet (friendly conversation theme)\n  - No matches found (search/filter theme)\n- **Icons**: Use Feather icons from @expo/vector-icons for all UI icons\n\n### Accessibility\n- Minimum touch target: 48x48dp\n- Color contrast ratio: 4.5:1 for text\n- Form field labels and placeholders clearly visible\n- Screen reader support for all interactive elements\n- Translation and report features clearly labeled","path":null,"size_bytes":7431,"size_tokens":null},"scripts/build.js":{"content":"const fs = require(\"fs\");\nconst path = require(\"path\");\nconst { spawn } = require(\"child_process\");\nconst { Readable } = require(\"stream\");\nconst { pipeline } = require(\"stream/promises\");\n\nlet metroProcess = null;\n\nfunction exitWithError(message) {\n  console.error(message);\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(1);\n}\n\nfunction setupSignalHandlers() {\n  const cleanup = () => {\n    if (metroProcess) {\n      console.log(\"Cleaning up Metro process...\");\n      metroProcess.kill();\n    }\n    process.exit(0);\n  };\n\n  process.on(\"SIGINT\", cleanup);\n  process.on(\"SIGTERM\", cleanup);\n  process.on(\"SIGHUP\", cleanup);\n}\n\nfunction getDeploymentUrl() {\n  if (process.env.REPLIT_INTERNAL_APP_DOMAIN) {\n    const url = `https://${process.env.REPLIT_INTERNAL_APP_DOMAIN}`;\n    console.log(\"Using REPLIT_INTERNAL_APP_DOMAIN:\", url);\n    return url;\n  }\n\n  if (process.env.REPLIT_DEV_DOMAIN) {\n    const url = `https://${process.env.REPLIT_DEV_DOMAIN}`;\n    console.log(\"Using REPLIT_DEV_DOMAIN:\", url);\n    return url;\n  }\n\n  console.error(\n    \"ERROR: REPLIT_INTERNAL_APP_DOMAIN and REPLIT_DEV_DOMAIN not set\",\n  );\n  process.exit(1);\n}\n\nfunction prepareDirectories(timestamp) {\n  console.log(\"Preparing build directories...\");\n\n  if (fs.existsSync(\"static-build\")) {\n    fs.rmSync(\"static-build\", { recursive: true });\n  }\n\n  const dirs = [\n    path.join(\"static-build\", timestamp, \"_expo\", \"static\", \"js\", \"ios\"),\n    path.join(\"static-build\", timestamp, \"_expo\", \"static\", \"js\", \"android\"),\n    path.join(\"static-build\", \"ios\"),\n    path.join(\"static-build\", \"android\"),\n  ];\n\n  for (const dir of dirs) {\n    fs.mkdirSync(dir, { recursive: true });\n  }\n\n  console.log(\"Build:\", timestamp);\n}\n\nfunction clearMetroCache() {\n  console.log(\"Clearing Metro cache...\");\n\n  const cacheDirs = [\n    ...fs.globSync(\".metro-cache\"),\n    ...fs.globSync(\"node_modules/.cache/metro\"),\n  ];\n\n  for (const dir of cacheDirs) {\n    fs.rmSync(dir, { recursive: true, force: true });\n  }\n\n  console.log(\"Cache cleared\");\n}\n\nasync function checkMetroHealth() {\n  try {\n    const response = await fetch(\"http://localhost:8081/status\", {\n      signal: AbortSignal.timeout(5000),\n    });\n    return response.ok;\n  } catch {\n    return false;\n  }\n}\n\nasync function startMetro() {\n  const isRunning = await checkMetroHealth();\n  if (isRunning) {\n    console.log(\"Metro already running\");\n    return;\n  }\n\n  console.log(\"Starting Metro...\");\n  metroProcess = spawn(\"npm\", [\"run\", \"expo:start:static:build\"], {\n    stdio: [\"ignore\", \"pipe\", \"pipe\"],\n    detached: false,\n  });\n\n  if (metroProcess.stdout) {\n    metroProcess.stdout.on(\"data\", (data) => {\n      const output = data.toString().trim();\n      if (output) console.log(`[Metro] ${output}`);\n    });\n  }\n  if (metroProcess.stderr) {\n    metroProcess.stderr.on(\"data\", (data) => {\n      const output = data.toString().trim();\n      if (output) console.error(`[Metro Error] ${output}`);\n    });\n  }\n\n  for (let i = 0; i < 60; i++) {\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n\n    const healthy = await checkMetroHealth();\n    if (healthy) {\n      console.log(\"Metro ready\");\n      return;\n    }\n  }\n\n  console.error(\"Metro timeout\");\n  process.exit(1);\n}\n\nasync function downloadFile(url, outputPath) {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), 120_000);\n\n  try {\n    console.log(`Downloading: ${url}`);\n    const response = await fetch(url, { signal: controller.signal });\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n\n    const file = fs.createWriteStream(outputPath);\n    await pipeline(Readable.fromWeb(response.body), file);\n\n    const fileSize = fs.statSync(outputPath).size;\n\n    if (fileSize === 0) {\n      fs.unlinkSync(outputPath);\n      throw new Error(\"Downloaded file is empty\");\n    }\n  } catch (error) {\n    if (fs.existsSync(outputPath)) {\n      fs.unlinkSync(outputPath);\n    }\n\n    if (error.name === \"AbortError\") {\n      throw new Error(`Download timeout after 2m: ${url}`);\n    }\n    throw error;\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\nasync function downloadBundle(platform, timestamp) {\n  const url = new URL(\"http://localhost:8081/client/index.bundle\");\n  url.searchParams.set(\"platform\", platform);\n  url.searchParams.set(\"dev\", \"false\");\n  url.searchParams.set(\"hot\", \"false\");\n  url.searchParams.set(\"lazy\", \"false\");\n  url.searchParams.set(\"minify\", \"true\");\n\n  const output = path.join(\n    \"static-build\",\n    timestamp,\n    \"_expo\",\n    \"static\",\n    \"js\",\n    platform,\n    \"bundle.js\",\n  );\n\n  console.log(`Fetching ${platform} bundle...`);\n  await downloadFile(url.toString(), output);\n  console.log(`${platform} bundle ready`);\n}\n\nasync function downloadManifest(platform) {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), 300_000);\n\n  try {\n    console.log(`Fetching ${platform} manifest...`);\n    const response = await fetch(\"http://localhost:8081/manifest\", {\n      headers: { \"expo-platform\": platform },\n      signal: controller.signal,\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}`);\n    }\n\n    const manifest = await response.json();\n    console.log(`${platform} manifest ready`);\n    return manifest;\n  } catch (error) {\n    if (error.name === \"AbortError\") {\n      throw new Error(\n        `Manifest download timeout after 5m for platform: ${platform}`,\n      );\n    }\n    throw error;\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\nasync function downloadBundlesAndManifests(timestamp) {\n  console.log(\"Downloading bundles and manifests...\");\n  console.log(\"This may take several minutes for production builds...\");\n\n  try {\n    const results = await Promise.allSettled([\n      downloadBundle(\"ios\", timestamp),\n      downloadBundle(\"android\", timestamp),\n      downloadManifest(\"ios\"),\n      downloadManifest(\"android\"),\n    ]);\n\n    const failures = results\n      .map((result, index) => ({ result, index }))\n      .filter(({ result }) => result.status === \"rejected\");\n\n    if (failures.length > 0) {\n      const errorMessages = failures.map(({ result, index }) => {\n        const names = [\n          \"iOS bundle\",\n          \"Android bundle\",\n          \"iOS manifest\",\n          \"Android manifest\",\n        ];\n        return `  - ${names[index]}: ${result.reason?.message || result.reason}`;\n      });\n\n      exitWithError(`Download failed:\\n${errorMessages.join(\"\\n\")}`);\n    }\n\n    const iosManifest =\n      results[2].status === \"fulfilled\" ? results[2].value : null;\n    const androidManifest =\n      results[3].status === \"fulfilled\" ? results[3].value : null;\n\n    console.log(\"All downloads completed successfully\");\n    return { ios: iosManifest, android: androidManifest };\n  } catch (error) {\n    exitWithError(`Unexpected download error: ${error.message}`);\n  }\n}\n\nfunction extractAssets(timestamp) {\n  const bundles = {\n    ios: fs.readFileSync(\n      path.join(\n        \"static-build\",\n        timestamp,\n        \"_expo\",\n        \"static\",\n        \"js\",\n        \"ios\",\n        \"bundle.js\",\n      ),\n      \"utf-8\",\n    ),\n    android: fs.readFileSync(\n      path.join(\n        \"static-build\",\n        timestamp,\n        \"_expo\",\n        \"static\",\n        \"js\",\n        \"android\",\n        \"bundle.js\",\n      ),\n      \"utf-8\",\n    ),\n  };\n\n  const assetsMap = new Map();\n  const assetPattern =\n    /httpServerLocation:\"([^\"]+)\"[^}]*hash:\"([^\"]+)\"[^}]*name:\"([^\"]+)\"[^}]*type:\"([^\"]+)\"/g;\n\n  const extractFromBundle = (bundle, platform) => {\n    for (const match of bundle.matchAll(assetPattern)) {\n      const originalPath = match[1];\n      const filename = match[3] + \".\" + match[4];\n\n      const tempUrl = new URL(`http://localhost:8081${originalPath}`);\n      const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n      if (!unstablePath) {\n        throw new Error(`Asset missing unstable_path: ${originalPath}`);\n      }\n\n      const decodedPath = decodeURIComponent(unstablePath);\n      const key = path.posix.join(decodedPath, filename);\n\n      if (!assetsMap.has(key)) {\n        const asset = {\n          url: path.posix.join(\"/\", decodedPath, filename),\n          originalPath: originalPath,\n          filename: filename,\n          relativePath: decodedPath,\n          hash: match[2],\n          platforms: new Set(),\n        };\n\n        assetsMap.set(key, asset);\n      }\n      assetsMap.get(key).platforms.add(platform);\n    }\n  };\n\n  extractFromBundle(bundles.ios, \"ios\");\n  extractFromBundle(bundles.android, \"android\");\n\n  return Array.from(assetsMap.values());\n}\n\nasync function downloadAssets(assets, timestamp) {\n  if (assets.length === 0) {\n    return 0;\n  }\n\n  console.log(\"Downloading assets...\");\n  let successCount = 0;\n  const failures = [];\n\n  const downloadPromises = assets.map(async (asset) => {\n    const platform = Array.from(asset.platforms)[0];\n\n    const tempUrl = new URL(`http://localhost:8081${asset.originalPath}`);\n    const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n    if (!unstablePath) {\n      throw new Error(`Asset missing unstable_path: ${asset.originalPath}`);\n    }\n\n    const decodedPath = decodeURIComponent(unstablePath);\n    const metroUrl = new URL(\n      `http://localhost:8081${path.posix.join(\"/assets\", decodedPath, asset.filename)}`,\n    );\n    metroUrl.searchParams.set(\"platform\", platform);\n    metroUrl.searchParams.set(\"hash\", asset.hash);\n\n    const outputDir = path.join(\n      \"static-build\",\n      timestamp,\n      \"_expo\",\n      \"static\",\n      \"js\",\n      asset.relativePath,\n    );\n    fs.mkdirSync(outputDir, { recursive: true });\n    const output = path.join(outputDir, asset.filename);\n\n    try {\n      await downloadFile(metroUrl.toString(), output);\n      successCount++;\n    } catch (error) {\n      failures.push({\n        filename: asset.filename,\n        error: error.message,\n        url: metroUrl.toString(),\n      });\n    }\n  });\n\n  await Promise.all(downloadPromises);\n\n  if (failures.length > 0) {\n    const errorMsg =\n      `Failed to download ${failures.length} asset(s):\\n` +\n      failures\n        .map((f) => `  - ${f.filename}: ${f.error} (${f.url})`)\n        .join(\"\\n\");\n    exitWithError(errorMsg);\n  }\n\n  console.log(`Downloaded ${successCount} assets`);\n  return successCount;\n}\n\nfunction updateBundleUrls(timestamp, baseUrl) {\n  const updateForPlatform = (platform) => {\n    const bundlePath = path.join(\n      \"static-build\",\n      timestamp,\n      \"_expo\",\n      \"static\",\n      \"js\",\n      platform,\n      \"bundle.js\",\n    );\n    let bundle = fs.readFileSync(bundlePath, \"utf-8\");\n\n    bundle = bundle.replace(\n      /httpServerLocation:\"(\\/[^\"]+)\"/g,\n      (_match, capturedPath) => {\n        const tempUrl = new URL(`http://localhost:8081${capturedPath}`);\n        const unstablePath = tempUrl.searchParams.get(\"unstable_path\");\n\n        if (!unstablePath) {\n          throw new Error(\n            `Asset missing unstable_path in bundle: ${capturedPath}`,\n          );\n        }\n\n        const decodedPath = decodeURIComponent(unstablePath);\n        return `httpServerLocation:\"${baseUrl}/${timestamp}/_expo/static/js/${decodedPath}\"`;\n      },\n    );\n\n    fs.writeFileSync(bundlePath, bundle);\n  };\n\n  updateForPlatform(\"ios\");\n  updateForPlatform(\"android\");\n  console.log(\"Updated bundle URLs\");\n}\n\nfunction updateManifests(manifests, timestamp, baseUrl, assetsByHash) {\n  const updateForPlatform = (platform, manifest) => {\n    if (!manifest.launchAsset || !manifest.extra) {\n      exitWithError(`Malformed manifest for ${platform}`);\n    }\n\n    manifest.launchAsset.url = `${baseUrl}/${timestamp}/_expo/static/js/${platform}/bundle.js`;\n    manifest.launchAsset.key = `bundle-${timestamp}`;\n    manifest.createdAt = new Date(\n      Number(timestamp.split(\"-\")[0]),\n    ).toISOString();\n    manifest.extra.expoClient.hostUri =\n      baseUrl.replace(\"https://\", \"\") + \"/\" + platform;\n    manifest.extra.expoGo.debuggerHost =\n      baseUrl.replace(\"https://\", \"\") + \"/\" + platform;\n    manifest.extra.expoGo.packagerOpts.dev = false;\n\n    if (manifest.assets && manifest.assets.length > 0) {\n      manifest.assets.forEach((asset) => {\n        if (!asset.url) return;\n\n        const hash = asset.hash;\n        if (!hash) return;\n\n        const assetInfo = assetsByHash.get(hash);\n        if (!assetInfo) return;\n\n        asset.url = `${baseUrl}/${timestamp}/_expo/static/js/${assetInfo.relativePath}/${assetInfo.filename}`;\n      });\n    }\n\n    fs.writeFileSync(\n      path.join(\"static-build\", platform, \"manifest.json\"),\n      JSON.stringify(manifest, null, 2),\n    );\n  };\n\n  updateForPlatform(\"ios\", manifests.ios);\n  updateForPlatform(\"android\", manifests.android);\n  console.log(\"Manifests updated\");\n}\n\nasync function main() {\n  console.log(\"Building static Expo Go deployment...\");\n\n  setupSignalHandlers();\n\n  const baseUrl = getDeploymentUrl();\n  const timestamp = `${Date.now()}-${process.pid}`;\n\n  prepareDirectories(timestamp);\n  clearMetroCache();\n\n  await startMetro();\n\n  const downloadTimeout = 300000;\n  const downloadPromise = downloadBundlesAndManifests(timestamp);\n  const timeoutPromise = new Promise((_, reject) => {\n    setTimeout(() => {\n      reject(\n        new Error(\n          `Overall download timeout after ${downloadTimeout / 1000} seconds. ` +\n            \"Metro may be struggling to generate bundles. Check Metro logs above.\",\n        ),\n      );\n    }, downloadTimeout);\n  });\n\n  const manifests = await Promise.race([downloadPromise, timeoutPromise]);\n\n  console.log(\"Processing assets...\");\n  const assets = extractAssets(timestamp);\n  console.log(\"Found\", assets.length, \"unique asset(s)\");\n\n  const assetsByHash = new Map();\n  for (const asset of assets) {\n    assetsByHash.set(asset.hash, {\n      relativePath: asset.relativePath,\n      filename: asset.filename,\n    });\n  }\n\n  const assetCount = await downloadAssets(assets, timestamp);\n\n  if (assetCount > 0) {\n    updateBundleUrls(timestamp, baseUrl);\n  }\n\n  console.log(\"Updating manifests and creating landing page...\");\n  updateManifests(manifests, timestamp, baseUrl, assetsByHash);\n\n  console.log(\"Build complete! Deploy to:\", baseUrl);\n\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(0);\n}\n\nmain().catch((error) => {\n  console.error(\"Build failed:\", error.message);\n  if (metroProcess) {\n    metroProcess.kill();\n  }\n  process.exit(1);\n});\n","path":null,"size_bytes":14413,"size_tokens":null},"replit.md":{"content":"# LanChat - Replit Configuration\n\n## Overview\n\nLanChat is a language learning social mobile application built with Expo/React Native and Express. The app connects language learners with native speakers through a community-based chat platform. Users can discover language partners, engage in real-time messaging, and build profiles showcasing their native and learning languages.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Frontend Architecture\n- **Framework**: Expo SDK 54 with React Native 0.81\n- **Navigation**: React Navigation v7 with native stack and bottom tabs\n- **State Management**: TanStack React Query for server state, React Context for auth state\n- **UI Components**: Custom themed components (ThemedText, ThemedView, Button, Card) with Reanimated animations\n- **Styling**: Platform-aware design with blur effects on iOS, adaptive theming for light/dark modes\n- **Path Aliases**: `@/` maps to `client/`, `@shared/` maps to `shared/`\n\n### Backend Architecture\n- **Runtime**: Node.js with Express\n- **Database**: PostgreSQL with Drizzle ORM\n- **Authentication**: JWT-based with scrypt password hashing (custom implementation, not a third-party auth provider)\n- **File Storage**: Google Cloud Storage integration for user photos\n- **API Pattern**: RESTful endpoints under `/api/` prefix\n\n### Database Schema\nLocated in `shared/schema.ts`:\n- **users**: Profile data including languages, photos, online status\n- **messages**: Chat messages between users with reporting capability\n- **blockedUsers**: User blocking relationships\n- **reports**: Content and user reporting system\n\n### Authentication Flow\n1. Email/password registration creates user and returns JWT\n2. Token stored in AsyncStorage on client\n3. AuthContext manages session state and token refresh\n4. Protected routes require Bearer token in Authorization header\n\n### Key Screens\n- **AuthScreen**: Login/registration with email and password\n- **OnboardingScreen**: Language selection after registration\n- **CommunityScreen**: User discovery with filtering\n- **ChatsScreen**: Conversation list\n- **ChatScreen**: Real-time messaging with translation support\n- **ProfileScreen/EditProfileScreen**: User profile management\n\n## External Dependencies\n\n### Database\n- PostgreSQL via `DATABASE_URL` environment variable\n- Drizzle ORM for type-safe queries and migrations\n- Migrations stored in `/migrations` directory\n\n### Cloud Storage\n- Google Cloud Storage for user photo uploads\n- Replit sidecar endpoint at `http://127.0.0.1:1106` for credential management\n- Object ACL system for access control\n\n### Environment Variables Required\n- `DATABASE_URL`: PostgreSQL connection string\n- `SESSION_SECRET`: JWT signing secret (defaults to development value)\n- `EXPO_PUBLIC_DOMAIN`: API domain for client requests\n- `REPLIT_DEV_DOMAIN`: Development domain for CORS\n- `PUBLIC_OBJECT_SEARCH_PATHS`: Optional paths for public file access\n\n### NPM Scripts\n- `npm run expo:dev`: Start Expo development server\n- `npm run server:dev`: Start Express backend in development\n- `npm run all:dev`: Run both Expo and server concurrently\n- `npm run db:push`: Push schema changes to database","path":null,"size_bytes":3199,"size_tokens":null},"shared/schema.ts":{"content":"import { sql, relations } from \"drizzle-orm\";\nimport { pgTable, text, varchar, integer, boolean, timestamp, jsonb } from \"drizzle-orm/pg-core\";\nimport { createInsertSchema } from \"drizzle-zod\";\nimport { z } from \"zod\";\n\nexport const users = pgTable(\"users\", {\n  id: varchar(\"id\")\n    .primaryKey()\n    .default(sql`gen_random_uuid()`),\n  email: text(\"email\").notNull().unique(),\n  password: text(\"password\").notNull(),\n  name: text(\"name\").notNull(),\n  age: integer(\"age\"),\n  nativeLanguage: text(\"native_language\"),\n  learningLanguages: jsonb(\"learning_languages\").$type<string[]>().default([]),\n  hobbies: text(\"hobbies\"),\n  topics: text(\"topics\"),\n  country: text(\"country\"),\n  photos: jsonb(\"photos\").$type<string[]>().default([]),\n  avatarIndex: integer(\"avatar_index\").default(0),\n  isOnline: boolean(\"is_online\").default(false),\n  lastSeen: timestamp(\"last_seen\").defaultNow(),\n  createdAt: timestamp(\"created_at\").defaultNow(),\n  isBot: boolean(\"is_bot\").default(false),\n  pushToken: text(\"push_token\"),\n  isVerified: boolean(\"is_verified\").default(false),\n  verificationLevel: text(\"verification_level\").default(\"none\"),\n});\n\nexport const usersRelations = relations(users, ({ many }) => ({\n  sentMessages: many(messages, { relationName: \"sender\" }),\n  receivedMessages: many(messages, { relationName: \"receiver\" }),\n  blockedUsers: many(blockedUsers, { relationName: \"blocker\" }),\n  blockedBy: many(blockedUsers, { relationName: \"blocked\" }),\n  reportsMade: many(reports, { relationName: \"reporter\" }),\n  reportsReceived: many(reports, { relationName: \"reported\" }),\n}));\n\nexport const messages = pgTable(\"messages\", {\n  id: varchar(\"id\")\n    .primaryKey()\n    .default(sql`gen_random_uuid()`),\n  senderId: varchar(\"sender_id\").notNull().references(() => users.id),\n  receiverId: varchar(\"receiver_id\").notNull().references(() => users.id),\n  content: text(\"content\").notNull(),\n  createdAt: timestamp(\"created_at\").defaultNow(),\n  isReported: boolean(\"is_reported\").default(false),\n});\n\nexport const messagesRelations = relations(messages, ({ one }) => ({\n  sender: one(users, {\n    fields: [messages.senderId],\n    references: [users.id],\n    relationName: \"sender\",\n  }),\n  receiver: one(users, {\n    fields: [messages.receiverId],\n    references: [users.id],\n    relationName: \"receiver\",\n  }),\n}));\n\nexport const blockedUsers = pgTable(\"blocked_users\", {\n  id: varchar(\"id\")\n    .primaryKey()\n    .default(sql`gen_random_uuid()`),\n  blockerId: varchar(\"blocker_id\").notNull().references(() => users.id),\n  blockedId: varchar(\"blocked_id\").notNull().references(() => users.id),\n  createdAt: timestamp(\"created_at\").defaultNow(),\n});\n\nexport const blockedUsersRelations = relations(blockedUsers, ({ one }) => ({\n  blocker: one(users, {\n    fields: [blockedUsers.blockerId],\n    references: [users.id],\n    relationName: \"blocker\",\n  }),\n  blocked: one(users, {\n    fields: [blockedUsers.blockedId],\n    references: [users.id],\n    relationName: \"blocked\",\n  }),\n}));\n\nexport const reports = pgTable(\"reports\", {\n  id: varchar(\"id\")\n    .primaryKey()\n    .default(sql`gen_random_uuid()`),\n  reporterId: varchar(\"reporter_id\").notNull().references(() => users.id),\n  reportedId: varchar(\"reported_id\").notNull().references(() => users.id),\n  messageId: varchar(\"message_id\").references(() => messages.id),\n  reason: text(\"reason\"),\n  type: text(\"type\").notNull(),\n  createdAt: timestamp(\"created_at\").defaultNow(),\n});\n\nexport const reportsRelations = relations(reports, ({ one }) => ({\n  reporter: one(users, {\n    fields: [reports.reporterId],\n    references: [users.id],\n    relationName: \"reporter\",\n  }),\n  reported: one(users, {\n    fields: [reports.reportedId],\n    references: [users.id],\n    relationName: \"reported\",\n  }),\n  message: one(messages, {\n    fields: [reports.messageId],\n    references: [messages.id],\n  }),\n}));\n\nexport const insertUserSchema = createInsertSchema(users).pick({\n  email: true,\n  password: true,\n  name: true,\n});\n\nexport const loginSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(6),\n});\n\nexport const registerSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(6),\n  name: z.string().min(2),\n});\n\nexport const updateProfileSchema = z.object({\n  name: z.string().min(2).optional(),\n  age: z.number().min(18).max(100).optional(),\n  nativeLanguage: z.string().optional(),\n  learningLanguages: z.array(z.string()).optional(),\n  hobbies: z.string().optional(),\n  topics: z.string().optional(),\n  country: z.string().optional(),\n  photos: z.array(z.string()).optional(),\n  avatarIndex: z.number().min(0).max(3).optional(),\n});\n\nexport type InsertUser = z.infer<typeof insertUserSchema>;\nexport type User = typeof users.$inferSelect;\nexport type Message = typeof messages.$inferSelect;\nexport type BlockedUser = typeof blockedUsers.$inferSelect;\nexport type Report = typeof reports.$inferSelect;\n","path":null,"size_bytes":4891,"size_tokens":null}},"version":2}